/*@!Encoding:1252*/
/*
//  (c) Vector Informatik GmbH. All rights reserved.
//
//  This file contains definitions of structs and methods that may be used
//  to set and get the values of an ASN.1 defined packet's payload.
//
//  //This example demonstrates how to set a packet's payload:
//  LONG packetHandle;
//  struct DENM payload;
//  //you need to set the values of the variable "payload" yourself
//  packetHandle = API_InitDENMPacket();
//  if (packetHandle!=0) {
//    if (API_SetDENMParams(packetHandle, payload)==0) {
//      if (C2xCompletePacket(packetHandle)==0) {
//        C2xOutputPacket(packetHandle);
//      }
//    }
//  }
//                                                                             */
variables
{

  struct DENMItsPduHeader {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    LONG protocolVersion;   //INTEGER, 0...255, currentVersion(1)
    LONG messageID;   //INTEGER, 0...255, denm(1), cam(2), poi(3)
    INT64 stationID;   //INTEGER, 0...4294967295
  };

  struct DENMActionID {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    INT64 originatorStationID;   //INTEGER, 0...4294967295
    LONG sequenceNumber;   //INTEGER, 0...65535
  };

  struct DENMDirection {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    LONG directionValue;   //INTEGER, 0...3600
    DWORD directionConfidence;   //INTEGER, 1...127, withinZeroPointOneDegree(1), withinOneDegree(10), unavailable(127)
  };

  struct DENMPosConfidenceEllipse {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    LONG semiMajorConfidence;   //INTEGER, 0...4095, oneCentimeter(1), unavailable(4095)
    LONG semiMinorConfidence;   //INTEGER, 0...4095, oneCentimeter(1), unavailable(4095)
    struct DENMDirection semiMajorOrientation;   //SEQUENCE
  };

  struct DENMElevation {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    LONG elevationValue;   //INTEGER, -1000...7191
    DWORD elevationConfidence;   //INTEGER, 1...127, withinOneMeter(1), unavailable(127)
  };

  struct DENMReferencePosition {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    LONG latitude;   //INTEGER, -900000000...900000001
    LONG longitude;   //INTEGER, -1800000000...1800000001
    struct DENMPosConfidenceEllipse positionConfidenceEllipse;   //SEQUENCE
    struct DENMElevation elevation;   //SEQUENCE
  };

  struct DENMManagementContainer {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    struct DENMActionID actionID;   //SEQUENCE
    INT64 detectionTime;   //INTEGER, 0...3153600000000
    INT64 referenceTime;   //INTEGER, 0...3153600000000
    INT isNegation;   //BOOLEAN
    INT isCancellation;   //BOOLEAN
    struct DENMReferencePosition eventPosition;   //SEQUENCE
    INT relevanceDistance;   //ENUMERATED, lessThan50m(0), lessThan100m(1), lessThan200m(2), lessThan500m(3), lessThan1000m(4), lessThan5km(5), lessThan10km(6), over10km(7)
    INT relevanceTrafficDirection;   //ENUMERATED, unavailable(0), upstreamTraffic(1), downstreamTraffic(2), allTrafficDirection(3)
    struct OPT_LONG_ASN validityDuration;   //INTEGER, OPTIONAL, 0...86400
    struct OPT_DWORD_ASN transmissionInterval;   //INTEGER, OPTIONAL, 1...10000
  };

  struct DENMCauseCode {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    LONG causeCode;   //INTEGER, 0...255, reserved(0), trafficCondition(1), accident(2), roadworks(3), adverseWeatherCondition-Adhesion(6), hazardousLocation-SurfaceCondition(9), hazardousLocation-ObstacleOnTheRoad(10), hazardousLocation-AnimalOnTheRoad(11), humanPresenceOnTheRoad(12), wrongWayDriving(14), rescueAndRecoveryWorkInProgress(15), adverseWeatherCondition-ExtremeWeatherCondition(17), adverseWeatherCondition-Visibility(18), adverseWeatherCondition-Precipitation(19), slowVehicle(26), dangerousEndOfQueue(27), vehicleBreakdown(91), postCrash(92), humanProblem(93), stationaryVehicle(94), emergencyVehicleApproaching(95), hazardousLocation-DangerousCurve(96), collisionRisk(97), signalViolation(98), dangerousSituation(99)
    LONG subCauseCode;   //INTEGER, 0...255
  };

  struct DENMSituationContainer {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    LONG informationQuality;   //INTEGER, 0...7, unknown(0), lowest(1), highest(7)
    struct DENMCauseCode eventType;   //SEQUENCE
    struct DENMCauseCode linkedCause;   //SEQUENCE, OPTIONAL
  };

  struct DENMMovement {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    LONG vehicleSpeed;   //INTEGER, 0...16383
    DWORD vehicleSpeedConfidence;   //INTEGER, 1...127, withinOneCentimeterPerSec(1), withinOneMeterPerSec(100), outOfRange(126), unavailable(127)
  };

  struct DENMDeltaReferencePosition {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    LONG deltaLatitude;   //INTEGER, -131072...131071
    LONG deltaLongitude;   //INTEGER, -131072...131071
    LONG deltaElevation;   //INTEGER, -127...128
  };

  struct DENMPathPoint {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    struct DENMDeltaReferencePosition pathPosition;   //SEQUENCE
    LONG pathDeltaTime;   //INTEGER, 0...65535
  };

  struct DENMPathHistory {
    INT length;
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    struct DENMPathPoint arrayValue[40];   //SEQUENCE
  };

  struct DENMTraces {
    INT length;
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    struct DENMPathHistory arrayValue[7];   //SEQUENCE OF
  };

  struct DENMLocationContainer {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    struct DENMMovement eventSpeed;   //SEQUENCE, OPTIONAL
    struct DENMDirection eventPositionHeading;   //SEQUENCE, OPTIONAL
    struct DENMTraces traces;   //SEQUENCE OF
    struct OPT_ENUM_ASN roadClass;   //ENUMERATED, OPTIONAL, urban-NoStructuralSeparationToOppositeLanes(0), urban-WithStructuralSeparationToOppositeLanes(1), nonUrban-NoStructuralSeparationToOppositeLanes(2), nonUrban-WithStructuralSeparationToOppositeLanes(3)
  };

  struct DENMPositionOfPillars {
    INT length;
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    LONG arrayValue[3];   //INTEGER, 0...30, tenCentimeters(1), unknown(30)
  };

  struct DENMPositionOfOccupants {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    CHAR string[16];
    INT  stringLength;
  };

  struct DENMImpactReductionContainer {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    LONG heightLonCarrLeft;   //INTEGER, 0...100, oneCentimeter(1), unknown(100)
    LONG heightLonCarrRight;   //INTEGER, 0...100, oneCentimeter(1), unknown(100)
    LONG posLonCarrLeft;   //INTEGER, 0...127, oneCentimeter(1), unknown(127)
    LONG posLonCarrRight;   //INTEGER, 0...127, oneCentimeter(1), unknown(127)
    struct DENMPositionOfPillars positionOfPillars;   //SEQUENCE OF
    LONG posCentMass;   //INTEGER, 0...63, tenCentimeters(1), unknown(63)
    LONG wheelBaseVehicle;   //INTEGER, 0...127, tenCentimeters(1), unknown(127)
    LONG turningRadius;   //INTEGER, 0...255, point4Meters(1), unknown(255)
    LONG posFrontAx;   //INTEGER, 0...20, tenCentimeters(1), unknown(20)
    struct DENMPositionOfOccupants positionOfOccupants;   //BIT STRING
    DWORD vehicleMass;   //INTEGER, 1...1024
    INT requestResponseIndication;   //ENUMERATED, request(0), response(1)
  };

  struct DENMLightBarSirenInUse {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    CHAR string[2];
    INT  stringLength;
  };

  struct DENMDrivingLaneStatus {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    CHAR string[14];
    INT  stringLength;
  };

  struct DENMClosedLanes {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    struct OPT_ENUM_ASN hardShoulderStatus;   //ENUMERATED, OPTIONAL, availableForStopping(0), closed(1), availableForDriving(2)
    struct DENMDrivingLaneStatus drivingLaneStatus;   //BIT STRING
  };

  struct DENMRestrictedTypes {
    INT length;
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    LONG arrayValue[32];   //INTEGER, 0...255, unknown(0), pedestrian(1), cyclist(2), moped(3), motorcycle(4), passengerCar(5), bus(6), lightTruck(7), heavyTruck(8), trailer(9), specialVehicles(10), tram(11), roadSideUnit(15)
  };

  struct DENMItineraryPath {
    INT length;
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    struct DENMReferencePosition arrayValue[40];   //SEQUENCE
  };

  struct DENMRoadWorksContainerExtended {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    struct DENMLightBarSirenInUse lightBarSirenInUse;   //BIT STRING, OPTIONAL
    struct DENMClosedLanes closedLanes;   //SEQUENCE, OPTIONAL
    struct DENMRestrictedTypes restriction;   //SEQUENCE OF, OPTIONAL
    struct OPT_LONG_ASN speedLimit;   //INTEGER, OPTIONAL, 0...150, oneKmPerHour(1)
    struct DENMCauseCode incidentIndication;   //SEQUENCE, OPTIONAL
    struct DENMItineraryPath recommendedPath;   //SEQUENCE OF, OPTIONAL
  };

  struct DENMDangerousGoodsExtendedemergencyActionCode {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    CHAR string[256];
    INT  stringLength;
  };

  struct DENMDangerousGoodsExtendedphoneNumber {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    CHAR string[256];
    INT  stringLength;
  };

  struct DENMDangerousGoodsExtendedcompanyName {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    CHAR string[256];
    INT  stringLength;
  };

  struct DENMDangerousGoodsExtended {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    INT dangerousGoodsType;   //ENUMERATED, explosives1(0), explosives2(1), explosives3(2), explosives4(3), explosives5(4), explosives6(5), flammableGases(6), nonFlammableGases(7), toxicGases(8), flammableLiquids(9), flammableSolids(10), substancesLiableToSpontaneousCombustion(11), substancesEmittingFlammableGasesUponContactWithWater(12), oxidizingSubstances(13), organicPeroxides(14), toxicSubstances(15), infectiousSubstances(16), radioactiveMaterial(17), corrosiveSubstances(18), miscellaneousDangerousSubstances(19)
    LONG unNumber;   //INTEGER, 0...9999
    INT elevatedTemperature;   //BOOLEAN
    INT tunnelsRestricted;   //BOOLEAN
    INT limitedQuantity;   //BOOLEAN
    struct DENMDangerousGoodsExtendedemergencyActionCode emergencyActionCode;   //IA5String, OPTIONAL
    struct DENMDangerousGoodsExtendedphoneNumber phoneNumber;   //IA5String, OPTIONAL
    struct DENMDangerousGoodsExtendedcompanyName companyName;   //UTF8String, OPTIONAL
  };

  struct DENMWMInumber {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    CHAR string[3];
    INT  stringLength;
  };

  struct DENMVDS {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    CHAR string[6];
    INT  stringLength;
  };

  struct DENMVehicleIdentification {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    struct DENMWMInumber wMInumber;   //IA5String
    struct DENMVDS vDS;   //IA5String
  };

  struct DENMEnergyStorageType {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    CHAR string[7];
    INT  stringLength;
  };

  struct DENMStationaryVehicleContainer {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    LONG stationType;   //INTEGER, 0...255, unknown(0), pedestrian(1), cyclist(2), moped(3), motorcycle(4), passengerCar(5), bus(6), lightTruck(7), heavyTruck(8), trailer(9), specialVehicles(10), tram(11), roadSideUnit(15)
    struct OPT_ENUM_ASN stationarySince;   //ENUMERATED, OPTIONAL, lessThan1Minute(0), lessThan2Minutes(1), lessThan15Minutes(2), over15Minutes(3)
    struct DENMCauseCode stationaryCause;   //SEQUENCE, OPTIONAL
    struct DENMDangerousGoodsExtended carryingDangerousGoods;   //SEQUENCE, OPTIONAL
    struct OPT_LONG_ASN numberOfOccupants;   //INTEGER, OPTIONAL, 0...127
    struct DENMVehicleIdentification vehicleIdentification;   //SEQUENCE, OPTIONAL
    struct DENMEnergyStorageType energyStorageType;   //BIT STRING, OPTIONAL
  };

  struct DENMAlacarteContainer {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    struct OPT_LONG_ASN laneNumber;   //INTEGER, OPTIONAL, -1...14, offTheRoad(-1), hardShoulder(0), outermostDrivingLane(1), secondLaneFromOutside(2)
    struct DENMImpactReductionContainer impactReduction;   //SEQUENCE, OPTIONAL
    struct OPT_LONG_ASN externalTemperature;   //INTEGER, OPTIONAL, -60...67
    struct DENMRoadWorksContainerExtended roadWorks;   //SEQUENCE, OPTIONAL
    struct OPT_ENUM_ASN positioningSolution;   //ENUMERATED, OPTIONAL, noPositioningSolution(0), sGNSS(1), dGNSS(2), sGNSSplusDR(3), dGNSSplusDR(4), dR(5)
    struct DENMStationaryVehicleContainer stationaryVehicle;   //SEQUENCE, OPTIONAL
  };

  struct DENMDecentralizedEnvironmentalNotificationMessage {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    struct DENMManagementContainer management;   //SEQUENCE
    struct DENMSituationContainer situation;   //SEQUENCE, OPTIONAL
    struct DENMLocationContainer location;   //SEQUENCE, OPTIONAL
    struct DENMAlacarteContainer alacarte;   //SEQUENCE, OPTIONAL
  };

  struct DENM {
    INT isValidFlag;   //necessary if this struct is used as an optional field of a SEQUENCE
    struct DENMItsPduHeader header;   //SEQUENCE
    struct DENMDecentralizedEnvironmentalNotificationMessage denm;   //SEQUENCE
  };

}

LONG API_InitDENMPacket()
{
  return C2xInitPacket("DENM"); 
}

int API_SetDENMParams(LONG packetHandle, struct DENM value)
{
    int result;

  result = 0;

  SetDENMItsPduHeaderParams(packetHandle, value.header, "header");
  result = CheckLastError("DENM", gkFuncRefSet, result);

  SetDENMDecentralizedEnvironmentalNotificationMessageParams(packetHandle, value.denm, "denm");
  result = CheckLastError("DENM", gkFuncRefSet, result);

  return result;
}
int API_GetDENMParams(LONG packetHandle, struct DENM value)
{
    int result;

  result = 0;

  value.header.isValidFlag = 1;
  GetDENMItsPduHeaderParams(packetHandle, value.header, "header");
  result = CheckLastError("DENM", gkFuncRefGet, result);

  value.denm.isValidFlag = 1;
  GetDENMDecentralizedEnvironmentalNotificationMessageParams(packetHandle, value.denm, "denm");
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int SetDENMDecentralizedEnvironmentalNotificationMessageParams(LONG packetHandle, struct DENMDecentralizedEnvironmentalNotificationMessage value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "management");
  SetDENMManagementContainerParams(packetHandle, value.management, newPath);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "situation");
  if (value.situation.isValidFlag==1)
  {
    SetDENMSituationContainerParams(packetHandle, value.situation, newPath);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "location");
  if (value.location.isValidFlag==1)
  {
    SetDENMLocationContainerParams(packetHandle, value.location, newPath);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "alacarte");
  if (value.alacarte.isValidFlag==1)
  {
    SetDENMAlacarteContainerParams(packetHandle, value.alacarte, newPath);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  return result;
}
int GetDENMDecentralizedEnvironmentalNotificationMessageParams(LONG packetHandle, struct DENMDecentralizedEnvironmentalNotificationMessage value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "management");
  value.management.isValidFlag = 1;
  GetDENMManagementContainerParams(packetHandle, value.management, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "situation");
  value.situation.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.situation.isValidFlag==1)
  {
    GetDENMSituationContainerParams(packetHandle, value.situation, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "location");
  value.location.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.location.isValidFlag==1)
  {
    GetDENMLocationContainerParams(packetHandle, value.location, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "alacarte");
  value.alacarte.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.alacarte.isValidFlag==1)
  {
    GetDENMAlacarteContainerParams(packetHandle, value.alacarte, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  return result;
}

int SetDENMAlacarteContainerParams(LONG packetHandle, struct DENMAlacarteContainer value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneNumber");
  if (value.laneNumber.isValidFlag==1)
  {
    C2xSetTokenInt( packetHandle, "DENM", newPath, value.laneNumber.value);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "impactReduction");
  if (value.impactReduction.isValidFlag==1)
  {
    SetDENMImpactReductionContainerParams(packetHandle, value.impactReduction, newPath);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "externalTemperature");
  if (value.externalTemperature.isValidFlag==1)
  {
    C2xSetTokenInt( packetHandle, "DENM", newPath, value.externalTemperature.value);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "roadWorks");
  if (value.roadWorks.isValidFlag==1)
  {
    SetDENMRoadWorksContainerExtendedParams(packetHandle, value.roadWorks, newPath);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "positioningSolution");
  if (value.positioningSolution.isValidFlag==1)
  {
    C2xSetTokenInt( packetHandle, "DENM", newPath, value.positioningSolution.value);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationaryVehicle");
  if (value.stationaryVehicle.isValidFlag==1)
  {
    SetDENMStationaryVehicleContainerParams(packetHandle, value.stationaryVehicle, newPath);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  return result;
}
int GetDENMAlacarteContainerParams(LONG packetHandle, struct DENMAlacarteContainer value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneNumber");
  value.laneNumber.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.laneNumber.isValidFlag==1)
  {
    value.laneNumber.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "impactReduction");
  value.impactReduction.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.impactReduction.isValidFlag==1)
  {
    GetDENMImpactReductionContainerParams(packetHandle, value.impactReduction, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "externalTemperature");
  value.externalTemperature.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.externalTemperature.isValidFlag==1)
  {
    value.externalTemperature.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "roadWorks");
  value.roadWorks.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.roadWorks.isValidFlag==1)
  {
    GetDENMRoadWorksContainerExtendedParams(packetHandle, value.roadWorks, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "positioningSolution");
  value.positioningSolution.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.positioningSolution.isValidFlag==1)
  {
    value.positioningSolution.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationaryVehicle");
  value.stationaryVehicle.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.stationaryVehicle.isValidFlag==1)
  {
    GetDENMStationaryVehicleContainerParams(packetHandle, value.stationaryVehicle, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  return result;
}

int SetDENMStationaryVehicleContainerParams(LONG packetHandle, struct DENMStationaryVehicleContainer value, char oldPath[])
{
  char newPath[300];
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationType");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.stationType);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationarySince");
  if (value.stationarySince.isValidFlag==1)
  {
    C2xSetTokenInt( packetHandle, "DENM", newPath, value.stationarySince.value);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationaryCause");
  if (value.stationaryCause.isValidFlag==1)
  {
    SetDENMCauseCodeParams(packetHandle, value.stationaryCause, newPath);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "carryingDangerousGoods");
  if (value.carryingDangerousGoods.isValidFlag==1)
  {
    SetDENMDangerousGoodsExtendedParams(packetHandle, value.carryingDangerousGoods, newPath);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "numberOfOccupants");
  if (value.numberOfOccupants.isValidFlag==1)
  {
    C2xSetTokenInt( packetHandle, "DENM", newPath, value.numberOfOccupants.value);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vehicleIdentification");
  if (value.vehicleIdentification.isValidFlag==1)
  {
    SetDENMVehicleIdentificationParams(packetHandle, value.vehicleIdentification, newPath);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "energyStorageType");
  if (value.energyStorageType.isValidFlag==1)
  {
    for (j=0; j<value.energyStorageType.stringLength; j++)
    {
      C2xSetTokenBitOfBitString(packetHandle, "DENM", newPath, j, value.energyStorageType.string[j]);
      result = CheckLastError("DENM", gkFuncRefSet, result);
    }
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  return result;
}
int GetDENMStationaryVehicleContainerParams(LONG packetHandle, struct DENMStationaryVehicleContainer value, char oldPath[])
{
  char newPath[300];
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationType");
  value.stationType = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationarySince");
  value.stationarySince.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.stationarySince.isValidFlag==1)
  {
    value.stationarySince.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationaryCause");
  value.stationaryCause.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.stationaryCause.isValidFlag==1)
  {
    GetDENMCauseCodeParams(packetHandle, value.stationaryCause, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "carryingDangerousGoods");
  value.carryingDangerousGoods.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.carryingDangerousGoods.isValidFlag==1)
  {
    GetDENMDangerousGoodsExtendedParams(packetHandle, value.carryingDangerousGoods, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "numberOfOccupants");
  value.numberOfOccupants.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.numberOfOccupants.isValidFlag==1)
  {
    value.numberOfOccupants.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vehicleIdentification");
  value.vehicleIdentification.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.vehicleIdentification.isValidFlag==1)
  {
    GetDENMVehicleIdentificationParams(packetHandle, value.vehicleIdentification, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "energyStorageType");
  value.energyStorageType.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.energyStorageType.isValidFlag==1)
  {
    value.energyStorageType.stringLength = C2xGetTokenInt(packetHandle, "DENM", newPath);
    if ((result = CheckLastError("DENM", gkFuncRefGet, result))==0)
    {
      for (j=0; j<value.energyStorageType.stringLength; j++)
      {
        value.energyStorageType.string[j] = C2xGetTokenBitOfBitString(packetHandle, "DENM", newPath, j);
        result = CheckLastError("DENM", gkFuncRefGet, result);
      }
    }
  }

  return result;
}


int SetDENMVehicleIdentificationParams(LONG packetHandle, struct DENMVehicleIdentification value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "wMInumber");
  C2xSetTokenData( packetHandle, "DENM", newPath, value.wMInumber.stringLength, value.wMInumber.string);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vDS");
  C2xSetTokenData( packetHandle, "DENM", newPath, value.vDS.stringLength, value.vDS.string);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  return result;
}
int GetDENMVehicleIdentificationParams(LONG packetHandle, struct DENMVehicleIdentification value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "wMInumber");
  value.wMInumber.isValidFlag = 1;
  value.wMInumber.stringLength = C2xGetTokenData(packetHandle, "DENM", newPath, elcount(value.wMInumber.string), value.wMInumber.string);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vDS");
  value.vDS.isValidFlag = 1;
  value.vDS.stringLength = C2xGetTokenData(packetHandle, "DENM", newPath, elcount(value.vDS.string), value.vDS.string);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}



int SetDENMDangerousGoodsExtendedParams(LONG packetHandle, struct DENMDangerousGoodsExtended value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "dangerousGoodsType");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.dangerousGoodsType);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "unNumber");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.unNumber);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevatedTemperature");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.elevatedTemperature);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "tunnelsRestricted");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.tunnelsRestricted);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "limitedQuantity");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.limitedQuantity);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "emergencyActionCode");
  if (value.emergencyActionCode.isValidFlag==1)
  {
    C2xSetTokenData( packetHandle, "DENM", newPath, value.emergencyActionCode.stringLength, value.emergencyActionCode.string);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "phoneNumber");
  if (value.phoneNumber.isValidFlag==1)
  {
    C2xSetTokenData( packetHandle, "DENM", newPath, value.phoneNumber.stringLength, value.phoneNumber.string);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "companyName");
  if (value.companyName.isValidFlag==1)
  {
    C2xSetTokenData( packetHandle, "DENM", newPath, value.companyName.stringLength, value.companyName.string);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  return result;
}
int GetDENMDangerousGoodsExtendedParams(LONG packetHandle, struct DENMDangerousGoodsExtended value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "dangerousGoodsType");
  value.dangerousGoodsType = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "unNumber");
  value.unNumber = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevatedTemperature");
  value.elevatedTemperature = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "tunnelsRestricted");
  value.tunnelsRestricted = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "limitedQuantity");
  value.limitedQuantity = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "emergencyActionCode");
  value.emergencyActionCode.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.emergencyActionCode.isValidFlag==1)
  {
    value.emergencyActionCode.stringLength = C2xGetTokenData(packetHandle, "DENM", newPath, elcount(value.emergencyActionCode.string), value.emergencyActionCode.string);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "phoneNumber");
  value.phoneNumber.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.phoneNumber.isValidFlag==1)
  {
    value.phoneNumber.stringLength = C2xGetTokenData(packetHandle, "DENM", newPath, elcount(value.phoneNumber.string), value.phoneNumber.string);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "companyName");
  value.companyName.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.companyName.isValidFlag==1)
  {
    value.companyName.stringLength = C2xGetTokenData(packetHandle, "DENM", newPath, elcount(value.companyName.string), value.companyName.string);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  return result;
}




int SetDENMRoadWorksContainerExtendedParams(LONG packetHandle, struct DENMRoadWorksContainerExtended value, char oldPath[])
{
  char newPath[300];
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lightBarSirenInUse");
  if (value.lightBarSirenInUse.isValidFlag==1)
  {
    for (j=0; j<value.lightBarSirenInUse.stringLength; j++)
    {
      C2xSetTokenBitOfBitString(packetHandle, "DENM", newPath, j, value.lightBarSirenInUse.string[j]);
      result = CheckLastError("DENM", gkFuncRefSet, result);
    }
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "closedLanes");
  if (value.closedLanes.isValidFlag==1)
  {
    SetDENMClosedLanesParams(packetHandle, value.closedLanes, newPath);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "restriction");
  if (value.restriction.isValidFlag==1)
  {
    SetDENMRestrictedTypesParams(packetHandle, value.restriction, newPath);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimit");
  if (value.speedLimit.isValidFlag==1)
  {
    C2xSetTokenInt( packetHandle, "DENM", newPath, value.speedLimit.value);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "incidentIndication");
  if (value.incidentIndication.isValidFlag==1)
  {
    SetDENMCauseCodeParams(packetHandle, value.incidentIndication, newPath);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "recommendedPath");
  if (value.recommendedPath.isValidFlag==1)
  {
    SetDENMItineraryPathParams(packetHandle, value.recommendedPath, newPath);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  return result;
}
int GetDENMRoadWorksContainerExtendedParams(LONG packetHandle, struct DENMRoadWorksContainerExtended value, char oldPath[])
{
  char newPath[300];
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lightBarSirenInUse");
  value.lightBarSirenInUse.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.lightBarSirenInUse.isValidFlag==1)
  {
    value.lightBarSirenInUse.stringLength = C2xGetTokenInt(packetHandle, "DENM", newPath);
    if ((result = CheckLastError("DENM", gkFuncRefGet, result))==0)
    {
      for (j=0; j<value.lightBarSirenInUse.stringLength; j++)
      {
        value.lightBarSirenInUse.string[j] = C2xGetTokenBitOfBitString(packetHandle, "DENM", newPath, j);
        result = CheckLastError("DENM", gkFuncRefGet, result);
      }
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "closedLanes");
  value.closedLanes.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.closedLanes.isValidFlag==1)
  {
    GetDENMClosedLanesParams(packetHandle, value.closedLanes, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "restriction");
  value.restriction.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.restriction.isValidFlag==1)
  {
    GetDENMRestrictedTypesParams(packetHandle, value.restriction, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimit");
  value.speedLimit.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.speedLimit.isValidFlag==1)
  {
    value.speedLimit.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "incidentIndication");
  value.incidentIndication.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.incidentIndication.isValidFlag==1)
  {
    GetDENMCauseCodeParams(packetHandle, value.incidentIndication, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "recommendedPath");
  value.recommendedPath.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.recommendedPath.isValidFlag==1)
  {
    GetDENMItineraryPathParams(packetHandle, value.recommendedPath, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  return result;
}

int SetDENMItineraryPathParams(LONG packetHandle, struct DENMItineraryPath value, char oldPath[])
{
  char newPath[300];
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "DENM", oldPath);
  for (i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetDENMReferencePositionParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }

  return result;
}
int GetDENMItineraryPathParams(LONG packetHandle, struct DENMItineraryPath value, char oldPath[])
{
  char newPath[300];
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "DENM", oldPath);
  if ((result = CheckLastError("DENM", gkFuncRefGet, result))==0)
  {
    for (i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetDENMReferencePositionParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("DENM", gkFuncRefGet, result);
    }
  }

  return result;
}

int SetDENMRestrictedTypesParams(LONG packetHandle, struct DENMRestrictedTypes value, char oldPath[])
{
  char newPath[300];
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "DENM", oldPath);
  for (i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    C2xSetTokenInt( packetHandle, "DENM", newPath, value.arrayValue[i]);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }

  return result;
}
int GetDENMRestrictedTypesParams(LONG packetHandle, struct DENMRestrictedTypes value, char oldPath[])
{
  char newPath[300];
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "DENM", oldPath);
  if ((result = CheckLastError("DENM", gkFuncRefGet, result))==0)
  {
    for (i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      value.arrayValue[i] = C2xGetTokenInt(packetHandle, "DENM", newPath);
      result = CheckLastError("DENM", gkFuncRefGet, result);
    }
  }

  return result;
}

int SetDENMClosedLanesParams(LONG packetHandle, struct DENMClosedLanes value, char oldPath[])
{
  char newPath[300];
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "hardShoulderStatus");
  if (value.hardShoulderStatus.isValidFlag==1)
  {
    C2xSetTokenInt( packetHandle, "DENM", newPath, value.hardShoulderStatus.value);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "drivingLaneStatus");
  for (j=0; j<value.drivingLaneStatus.stringLength; j++)
  {
    C2xSetTokenBitOfBitString(packetHandle, "DENM", newPath, j, value.drivingLaneStatus.string[j]);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }

  return result;
}
int GetDENMClosedLanesParams(LONG packetHandle, struct DENMClosedLanes value, char oldPath[])
{
  char newPath[300];
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "hardShoulderStatus");
  value.hardShoulderStatus.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.hardShoulderStatus.isValidFlag==1)
  {
    value.hardShoulderStatus.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "drivingLaneStatus");
  value.drivingLaneStatus.isValidFlag = 1;
  value.drivingLaneStatus.stringLength = C2xGetTokenInt(packetHandle, "DENM", newPath);
  if ((result = CheckLastError("DENM", gkFuncRefGet, result))==0)
  {
    for (j=0; j<value.drivingLaneStatus.stringLength; j++)
    {
      value.drivingLaneStatus.string[j] = C2xGetTokenBitOfBitString(packetHandle, "DENM", newPath, j);
      result = CheckLastError("DENM", gkFuncRefGet, result);
    }
  }

  return result;
}



int SetDENMImpactReductionContainerParams(LONG packetHandle, struct DENMImpactReductionContainer value, char oldPath[])
{
  char newPath[300];
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heightLonCarrLeft");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.heightLonCarrLeft);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heightLonCarrRight");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.heightLonCarrRight);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posLonCarrLeft");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.posLonCarrLeft);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posLonCarrRight");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.posLonCarrRight);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "positionOfPillars");
  SetDENMPositionOfPillarsParams(packetHandle, value.positionOfPillars, newPath);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posCentMass");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.posCentMass);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "wheelBaseVehicle");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.wheelBaseVehicle);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "turningRadius");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.turningRadius);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posFrontAx");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.posFrontAx);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "positionOfOccupants");
  for (j=0; j<value.positionOfOccupants.stringLength; j++)
  {
    C2xSetTokenBitOfBitString(packetHandle, "DENM", newPath, j, value.positionOfOccupants.string[j]);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vehicleMass");
  C2xSetTokenInt64( packetHandle, "DENM", newPath, value.vehicleMass);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "requestResponseIndication");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.requestResponseIndication);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  return result;
}
int GetDENMImpactReductionContainerParams(LONG packetHandle, struct DENMImpactReductionContainer value, char oldPath[])
{
  char newPath[300];
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heightLonCarrLeft");
  value.heightLonCarrLeft = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heightLonCarrRight");
  value.heightLonCarrRight = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posLonCarrLeft");
  value.posLonCarrLeft = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posLonCarrRight");
  value.posLonCarrRight = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "positionOfPillars");
  GetDENMPositionOfPillarsParams(packetHandle, value.positionOfPillars, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posCentMass");
  value.posCentMass = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "wheelBaseVehicle");
  value.wheelBaseVehicle = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "turningRadius");
  value.turningRadius = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posFrontAx");
  value.posFrontAx = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "positionOfOccupants");
  value.positionOfOccupants.isValidFlag = 1;
  value.positionOfOccupants.stringLength = C2xGetTokenInt(packetHandle, "DENM", newPath);
  if ((result = CheckLastError("DENM", gkFuncRefGet, result))==0)
  {
    for (j=0; j<value.positionOfOccupants.stringLength; j++)
    {
      value.positionOfOccupants.string[j] = C2xGetTokenBitOfBitString(packetHandle, "DENM", newPath, j);
      result = CheckLastError("DENM", gkFuncRefGet, result);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vehicleMass");
  value.vehicleMass = C2xGetTokenInt64(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "requestResponseIndication");
  value.requestResponseIndication = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}


int SetDENMPositionOfPillarsParams(LONG packetHandle, struct DENMPositionOfPillars value, char oldPath[])
{
  char newPath[300];
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "DENM", oldPath);
  for (i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    C2xSetTokenInt( packetHandle, "DENM", newPath, value.arrayValue[i]);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }

  return result;
}
int GetDENMPositionOfPillarsParams(LONG packetHandle, struct DENMPositionOfPillars value, char oldPath[])
{
  char newPath[300];
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "DENM", oldPath);
  if ((result = CheckLastError("DENM", gkFuncRefGet, result))==0)
  {
    for (i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      value.arrayValue[i] = C2xGetTokenInt(packetHandle, "DENM", newPath);
      result = CheckLastError("DENM", gkFuncRefGet, result);
    }
  }

  return result;
}

int SetDENMLocationContainerParams(LONG packetHandle, struct DENMLocationContainer value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventSpeed");
  if (value.eventSpeed.isValidFlag==1)
  {
    SetDENMMovementParams(packetHandle, value.eventSpeed, newPath);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventPositionHeading");
  if (value.eventPositionHeading.isValidFlag==1)
  {
    SetDENMDirectionParams(packetHandle, value.eventPositionHeading, newPath);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "traces");
  SetDENMTracesParams(packetHandle, value.traces, newPath);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "roadClass");
  if (value.roadClass.isValidFlag==1)
  {
    C2xSetTokenInt( packetHandle, "DENM", newPath, value.roadClass.value);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  return result;
}
int GetDENMLocationContainerParams(LONG packetHandle, struct DENMLocationContainer value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventSpeed");
  value.eventSpeed.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.eventSpeed.isValidFlag==1)
  {
    GetDENMMovementParams(packetHandle, value.eventSpeed, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventPositionHeading");
  value.eventPositionHeading.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.eventPositionHeading.isValidFlag==1)
  {
    GetDENMDirectionParams(packetHandle, value.eventPositionHeading, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "traces");
  GetDENMTracesParams(packetHandle, value.traces, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "roadClass");
  value.roadClass.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.roadClass.isValidFlag==1)
  {
    value.roadClass.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  return result;
}

int SetDENMTracesParams(LONG packetHandle, struct DENMTraces value, char oldPath[])
{
  char newPath[300];
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "DENM", oldPath);
  for (i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetDENMPathHistoryParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }

  return result;
}
int GetDENMTracesParams(LONG packetHandle, struct DENMTraces value, char oldPath[])
{
  char newPath[300];
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "DENM", oldPath);
  if ((result = CheckLastError("DENM", gkFuncRefGet, result))==0)
  {
    for (i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetDENMPathHistoryParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("DENM", gkFuncRefGet, result);
    }
  }

  return result;
}

int SetDENMPathHistoryParams(LONG packetHandle, struct DENMPathHistory value, char oldPath[])
{
  char newPath[300];
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "DENM", oldPath);
  for (i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetDENMPathPointParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }

  return result;
}
int GetDENMPathHistoryParams(LONG packetHandle, struct DENMPathHistory value, char oldPath[])
{
  char newPath[300];
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "DENM", oldPath);
  if ((result = CheckLastError("DENM", gkFuncRefGet, result))==0)
  {
    for (i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetDENMPathPointParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("DENM", gkFuncRefGet, result);
    }
  }

  return result;
}

int SetDENMPathPointParams(LONG packetHandle, struct DENMPathPoint value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathPosition");
  SetDENMDeltaReferencePositionParams(packetHandle, value.pathPosition, newPath);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathDeltaTime");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.pathDeltaTime);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  return result;
}
int GetDENMPathPointParams(LONG packetHandle, struct DENMPathPoint value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathPosition");
  value.pathPosition.isValidFlag = 1;
  GetDENMDeltaReferencePositionParams(packetHandle, value.pathPosition, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathDeltaTime");
  value.pathDeltaTime = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int SetDENMDeltaReferencePositionParams(LONG packetHandle, struct DENMDeltaReferencePosition value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "deltaLatitude");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.deltaLatitude);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "deltaLongitude");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.deltaLongitude);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "deltaElevation");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.deltaElevation);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  return result;
}
int GetDENMDeltaReferencePositionParams(LONG packetHandle, struct DENMDeltaReferencePosition value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "deltaLatitude");
  value.deltaLatitude = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "deltaLongitude");
  value.deltaLongitude = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "deltaElevation");
  value.deltaElevation = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int SetDENMMovementParams(LONG packetHandle, struct DENMMovement value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vehicleSpeed");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.vehicleSpeed);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vehicleSpeedConfidence");
  C2xSetTokenInt64( packetHandle, "DENM", newPath, value.vehicleSpeedConfidence);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  return result;
}
int GetDENMMovementParams(LONG packetHandle, struct DENMMovement value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vehicleSpeed");
  value.vehicleSpeed = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vehicleSpeedConfidence");
  value.vehicleSpeedConfidence = C2xGetTokenInt64(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int SetDENMSituationContainerParams(LONG packetHandle, struct DENMSituationContainer value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "informationQuality");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.informationQuality);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventType");
  SetDENMCauseCodeParams(packetHandle, value.eventType, newPath);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "linkedCause");
  if (value.linkedCause.isValidFlag==1)
  {
    SetDENMCauseCodeParams(packetHandle, value.linkedCause, newPath);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  return result;
}
int GetDENMSituationContainerParams(LONG packetHandle, struct DENMSituationContainer value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "informationQuality");
  value.informationQuality = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventType");
  value.eventType.isValidFlag = 1;
  GetDENMCauseCodeParams(packetHandle, value.eventType, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "linkedCause");
  value.linkedCause.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.linkedCause.isValidFlag==1)
  {
    GetDENMCauseCodeParams(packetHandle, value.linkedCause, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  return result;
}

int SetDENMCauseCodeParams(LONG packetHandle, struct DENMCauseCode value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "causeCode");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.causeCode);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "subCauseCode");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.subCauseCode);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  return result;
}
int GetDENMCauseCodeParams(LONG packetHandle, struct DENMCauseCode value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "causeCode");
  value.causeCode = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "subCauseCode");
  value.subCauseCode = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int SetDENMManagementContainerParams(LONG packetHandle, struct DENMManagementContainer value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "actionID");
  SetDENMActionIDParams(packetHandle, value.actionID, newPath);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "detectionTime");
  C2xSetTokenInt64( packetHandle, "DENM", newPath, value.detectionTime);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "referenceTime");
  C2xSetTokenInt64( packetHandle, "DENM", newPath, value.referenceTime);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "isNegation");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.isNegation);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "isCancellation");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.isCancellation);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventPosition");
  SetDENMReferencePositionParams(packetHandle, value.eventPosition, newPath);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "relevanceDistance");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.relevanceDistance);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "relevanceTrafficDirection");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.relevanceTrafficDirection);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "validityDuration");
  if (value.validityDuration.isValidFlag==1)
  {
    C2xSetTokenInt( packetHandle, "DENM", newPath, value.validityDuration.value);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "transmissionInterval");
  if (value.transmissionInterval.isValidFlag==1)
  {
    C2xSetTokenInt64( packetHandle, "DENM", newPath, value.transmissionInterval.value);
    result = CheckLastError("DENM", gkFuncRefSet, result);
  }
  else
  {
    C2xRemoveToken(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefRemove, result);
  }

  return result;
}
int GetDENMManagementContainerParams(LONG packetHandle, struct DENMManagementContainer value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "actionID");
  value.actionID.isValidFlag = 1;
  GetDENMActionIDParams(packetHandle, value.actionID, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "detectionTime");
  value.detectionTime = C2xGetTokenInt64(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "referenceTime");
  value.referenceTime = C2xGetTokenInt64(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "isNegation");
  value.isNegation = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "isCancellation");
  value.isCancellation = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventPosition");
  value.eventPosition.isValidFlag = 1;
  GetDENMReferencePositionParams(packetHandle, value.eventPosition, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "relevanceDistance");
  value.relevanceDistance = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "relevanceTrafficDirection");
  value.relevanceTrafficDirection = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "validityDuration");
  value.validityDuration.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.validityDuration.isValidFlag==1)
  {
    value.validityDuration.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "transmissionInterval");
  value.transmissionInterval.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if (value.transmissionInterval.isValidFlag==1)
  {
    value.transmissionInterval.value = C2xGetTokenInt64(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }

  return result;
}

int SetDENMReferencePositionParams(LONG packetHandle, struct DENMReferencePosition value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latitude");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.latitude);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longitude");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.longitude);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "positionConfidenceEllipse");
  SetDENMPosConfidenceEllipseParams(packetHandle, value.positionConfidenceEllipse, newPath);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevation");
  SetDENMElevationParams(packetHandle, value.elevation, newPath);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  return result;
}
int GetDENMReferencePositionParams(LONG packetHandle, struct DENMReferencePosition value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latitude");
  value.latitude = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longitude");
  value.longitude = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "positionConfidenceEllipse");
  value.positionConfidenceEllipse.isValidFlag = 1;
  GetDENMPosConfidenceEllipseParams(packetHandle, value.positionConfidenceEllipse, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevation");
  value.elevation.isValidFlag = 1;
  GetDENMElevationParams(packetHandle, value.elevation, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int SetDENMElevationParams(LONG packetHandle, struct DENMElevation value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevationValue");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.elevationValue);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevationConfidence");
  C2xSetTokenInt64( packetHandle, "DENM", newPath, value.elevationConfidence);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  return result;
}
int GetDENMElevationParams(LONG packetHandle, struct DENMElevation value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevationValue");
  value.elevationValue = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevationConfidence");
  value.elevationConfidence = C2xGetTokenInt64(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int SetDENMPosConfidenceEllipseParams(LONG packetHandle, struct DENMPosConfidenceEllipse value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "semiMajorConfidence");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.semiMajorConfidence);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "semiMinorConfidence");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.semiMinorConfidence);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "semiMajorOrientation");
  SetDENMDirectionParams(packetHandle, value.semiMajorOrientation, newPath);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  return result;
}
int GetDENMPosConfidenceEllipseParams(LONG packetHandle, struct DENMPosConfidenceEllipse value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "semiMajorConfidence");
  value.semiMajorConfidence = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "semiMinorConfidence");
  value.semiMinorConfidence = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "semiMajorOrientation");
  value.semiMajorOrientation.isValidFlag = 1;
  GetDENMDirectionParams(packetHandle, value.semiMajorOrientation, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int SetDENMDirectionParams(LONG packetHandle, struct DENMDirection value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "directionValue");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.directionValue);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "directionConfidence");
  C2xSetTokenInt64( packetHandle, "DENM", newPath, value.directionConfidence);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  return result;
}
int GetDENMDirectionParams(LONG packetHandle, struct DENMDirection value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "directionValue");
  value.directionValue = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "directionConfidence");
  value.directionConfidence = C2xGetTokenInt64(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int SetDENMActionIDParams(LONG packetHandle, struct DENMActionID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "originatorStationID");
  C2xSetTokenInt64( packetHandle, "DENM", newPath, value.originatorStationID);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sequenceNumber");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.sequenceNumber);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  return result;
}
int GetDENMActionIDParams(LONG packetHandle, struct DENMActionID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "originatorStationID");
  value.originatorStationID = C2xGetTokenInt64(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sequenceNumber");
  value.sequenceNumber = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int SetDENMItsPduHeaderParams(LONG packetHandle, struct DENMItsPduHeader value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "protocolVersion");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.protocolVersion);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "messageID");
  C2xSetTokenInt( packetHandle, "DENM", newPath, value.messageID);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationID");
  C2xSetTokenInt64( packetHandle, "DENM", newPath, value.stationID);
  result = CheckLastError("DENM", gkFuncRefSet, result);

  return result;
}
int GetDENMItsPduHeaderParams(LONG packetHandle, struct DENMItsPduHeader value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "protocolVersion");
  value.protocolVersion = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "messageID");
  value.messageID = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationID");
  value.stationID = C2xGetTokenInt64(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

