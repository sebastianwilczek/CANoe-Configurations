/*@!Encoding:1252*/
// *************************************************************************************
//
//  Visualizes Messages (e.g. DENMs). Currently supported: 
//    - Roadworks Warning DENM
//
// *************************************************************************************

includes
{
  #include "..\DataSources\ASNV_Template_BaseDatatypes.cin"
  #include "..\DataSources\ASNV_Template_DENM.cin"
} 

variables
{
  const float cMultiplier = 10000000.0; // Multiplier for GPS-coordinates
  
  enum gEnumFigures { Square = 1, Rectangle = 2, Ellipse = 3, Cross = 4, Triangle = 5, Line = 6, Bitmap = 7, Text = 8 };  // Figures of the CAPL-Map Drawining-API
  
  // RGB color codes, will be set on start
  double gWhite;    // Hex FFFFFF     
  double gTurquoise;// Hex FFFF00     
  double gMagenta;  // Hex FF00FF      
  double gRed;      // Hex FF0000     
  double gGrey;     // Hex C0C0C0      
  double gYellow;   // Hex FFFF00       
  double gGreen;    // Hex 00FF00                              
  double gBlue;     // Hex 0000FF           
  double gBlack;    // Hex 000000                                 
  double gTransparent;
  
  LONG waypointHandles[10];         // Handle array for drawing pathpoints to the RWW
  LONG waypointHandlesText[10];     // Handle array for drawing pathpoints to the RWW
  LONG relevanceAreaHandle   = 0;   // Handle for Relevance Area drawn by by CAPL-Map Drawing-API
  LONG rwwImgHandle          = 0;   // Handle for RWW image drawn by CAPL-Map Drawing-API
  LONG rsuHandle             = 0;   // Handle for the RSU text grafic object drawn by CAPL-Map Drawing-API
  
  struct  DENM denmPdu;             // Structure of the imported reference ASN1 DENM
  
}

on start
{
  // register the receive callback
  C2xRegisterCallback(0, "OnC2xPacket");
  
  //Set RGB Color Codes 
  gWhite=makeRGB(255,255,255);
  gTurquoise = makeRGB(255,255,00);
  gMagenta = makeRGB(255,0,255);
  gRed = makeRGB(255,0,0);
  gGrey = makeRGB(192,192,192);
  gYellow = makeRGB(255, 255,0);
  gGreen = makeRGB(0,255,0);
  gBlue = makeRGB(0,0,255);
  gBlack = makeRGB(0,0,0);
  gTransparent = makeARGB(0,255,255,255);
}

// **************************************************************** 
// Called on every sent/received C2x Message
// ****************************************************************
void OnC2xPacket (LONG channel, LONG dir, LONG radioChannel, LONG signalStrength, LONG sigQuality, LONG packet)
{
  float  latitude;
  float  longitude;
  int    stationType;
  
  // If the message was received ...
  if(dir == RX)
  {
    // ... and its a message from an RSU ...
    stationType = C2xGetTokenInt(packet, "geo_cnh", "lpvNetAddrStType");
    // get coordinates and station type from sender
    latitude  = C2xGetTokenInt(packet, "geo_cnh", "lpvLat");
    latitude  = latitude/ 10 / 1000000;
    longitude = C2xGetTokenInt(packet, "geo_cnh", "lpvLong");
    longitude = longitude / 10 / 1000000;

    if(stationType == 9) // RSU
    {
      // ... and it is a DENM ...
      if(API_GetDENMParams(packet, denmPdu) == 0)
      {
        // ... and it is a Roadworks Warning DENM ...
        if(denmPdu.denm.situation.eventType.causeCode == 3) 
        {      
          // ... call the method which visualizes important rww data in the map window.
          VisualizeRWW(denmPdu);
          VisualizeRSU(latitude, longitude);
        }
      }
    }
  }
  
  // The user deactivated the sending process of the RWW, delete all corresponding handles
  if(@sysvar::ActivateRWW == 0)
  {
    DeleteAndResetHandles(); 
  }
}

// ****************************************************************************
//  Function extracts the RWW data from the DENM and creates/draws the 
//  corresponding objects in the Map Window
// ****************************************************************************
void VisualizeRWW(struct DENM denmPdu)
{
  float   relAreaCenterLat;       // Eventposition Latitude
  float   relAreaCenterLon;       // Eventposition Longitude
  float   deltaLat;               // Delta to the Latitude of the Eventposition (used for Path Points)
  float   deltaLon;               // Delta to the Longitude of the Eventposition (used for Path Points)
  float   headingRelevanceArea;   // Eventposition Heading
  float   radius;                 // Eventposition / Relevance Area Radius
  float   i;
  int     j;

  // Get the data from the DENM
  relAreaCenterLat      = denmPdu.denm.management.eventPosition.latitude / cMultiplier;
  relAreaCenterLon      = denmPdu.denm.management.eventPosition.longitude / cMultiplier;
  headingRelevanceArea  = denmPdu.denm.location.eventPositionHeading.directionValue / 10;

  // If Path Points are available...
  if(denmPdu.denm.location.traces.arrayValue[0].length > 0)
  { 
    // ... check for every of them ...
    for(i = 0; i < denmPdu.denm.location.traces.arrayValue[0].length; i++)
    {
      j = (int)i;
      // ... if they have a vaild position.
      if(denmPdu.denm.location.traces.arrayValue[0].arrayValue[j].pathPosition.isValidFlag == 1)
      {
        // Get the delta of the Path Point to the Eventposition
        deltaLat = denmPdu.denm.location.traces.arrayValue[0].arrayValue[j].pathPosition.deltaLatitude / cMultiplier;
        deltaLon = denmPdu.denm.location.traces.arrayValue[0].arrayValue[j].pathPosition.deltaLongitude / cMultiplier;
       
        // If there are yet no handles created...
        if (waypointHandles[j] == 0) 
        {
          // ... create a handle (BMP GFX object) for the Path Point. 
          waypointHandles[j] = C2xCreateMapObject(Bitmap);
          waypointHandlesText[j] = C2xCreateMapObject(Text);
        }
      
        // If there are already handles available...
        if (waypointHandles[j] != 0) 
        {
          // ... update the new values for the Path Point and draw it.
          C2xSetMapObjectPosition(waypointHandles[j], relAreaCenterLat + deltaLat, relAreaCenterLon + deltaLon);   
          C2xSetMapObjectBmpFilePath(waypointHandles[j], "Bitmaps\\pathPoint.bmp");
          C2xSetMapObjectSize(waypointHandles[j], 20, 20);
          C2xDrawMapObject(waypointHandles[j]);

          C2xSetMapObjectPosition(waypointHandlesText[j], relAreaCenterLat + deltaLat - 0.00009, relAreaCenterLon + deltaLon - 0.00004);   
          C2xSetMapObjectFillColor(waypointHandlesText[j], gBlack);
          C2xSetMapObjectText(waypointHandlesText[j], "%1.0f", i );
          C2xDrawMapObject(waypointHandlesText[j]);
        }    
      }
    }
  }
  
  // If there is yet no handle created for the Relevance Area...
  if(relevanceAreaHandle == 0)
  {
    // ... create a handle (Ellipse GFX object) for the Relevance Area.
    relevanceAreaHandle = C2xCreateMapObject(Ellipse);
  }
 
  // If there is already a handle available...
  if(relevanceAreaHandle != 0)
  {
    // ... update the new values for the Relevance Area
    C2xSetMapObjectPosition(relevanceAreaHandle, relAreaCenterLat, relAreaCenterLon );
    C2xSetMapObjectLineColor(relevanceAreaHandle, gRed);
    C2xSetMapObjectPenWidth(relevanceAreaHandle, 2);
    C2xSetMapObjectHeading(relevanceAreaHandle, headingRelevanceArea);
   
    // Multiply with 2 to get a Relevance Distance which is valid for both traffic directions
    switch(denmPdu.denm.management.relevanceDistance)
    {
      case 0:
        C2xSetMapObjectSize(relevanceAreaHandle, 50*2, 50*2);       // relevanceDistance = 0 means 50 metres, information taken from the DENM Specification.
        break;
      case 1:
        C2xSetMapObjectSize(relevanceAreaHandle, 100*2, 100*2);     // relevanceDistance = 1 means 100 metres, information taken from the DENM Specification
        break;
      case 2:
        C2xSetMapObjectSize(relevanceAreaHandle, 200*2, 200*2);     // relevanceDistance = 2 means 200 metres, information taken from the DENM Specification
        break;
      case 3:
        C2xSetMapObjectSize(relevanceAreaHandle, 500*2, 500*2);     // relevanceDistance = 3 means 500 metres, information taken from the DENM Specification
        break;
      case 4:
        C2xSetMapObjectSize(relevanceAreaHandle, 1000*2,1000*2);    // relevanceDistance = 4 means 1.000 metres, information taken from the DENM Specification
        break;
      case 5:
        C2xSetMapObjectSize(relevanceAreaHandle, 5000*2,5000*2);    // relevanceDistance = 5 means 5.000 metres, information taken from the DENM Specification
        break;
      case 6:
        C2xSetMapObjectSize(relevanceAreaHandle, 10000*2,10000*2);  // relevanceDistance = 6 means 10.000 metres, information taken from the DENM Specification
        break;
    } 

    C2xDrawMapObject(relevanceAreaHandle);
  }

  // If there is yet no handle created for the Event Image...
  if (rwwImgHandle == 0) 
  {
    // ... create a handle (Bitmap GFX object) for the Event Image.
    rwwImgHandle = C2xCreateMapObject(Bitmap);
  }
 
  // If there is already a handle available...
  if (rwwImgHandle != 0) 
  {
    //write ("test");
    // ... update the new values for the Event Image and draw it.
    C2xSetMapObjectPosition(rwwImgHandle, relAreaCenterLat, relAreaCenterLon );
    C2xSetMapObjectBmpFilePath(rwwImgHandle, "Bitmaps\\rww.bmp");
    C2xSetMapObjectSize(rwwImgHandle, 50, 50);
    C2xDrawMapObject(rwwImgHandle);
  }
}


void VisualizeRSU(float latitude, float longitude)
{
  latitude = latitude + 0.00008;
  longitude = longitude + 0.0002;

  if (rsuHandle == 0)
  {
    rsuHandle = C2xCreateMapObject(Text);
  }
  C2xSetMapObjectPosition(rsuHandle, latitude, longitude );
  C2xSetMapObjectText(rsuHandle, "RSU sending out DENM (RWW)");
  C2xSetMapObjectFillColor(rsuHandle, makeRGB(0,0,0));
  C2xDrawMapObject(rsuHandle);
}

// ****************************************************************************
//  function deletes and resets handles of the CAPL- MapWindow Drawing API
// ****************************************************************************
void DeleteAndResetHandles()
{
  int i = 0;
  
  // Delete and Reset Relevance Area Handle
  if(relevanceAreaHandle != 0)
  {
    C2xDeleteMapObject(relevanceAreaHandle);
    relevanceAreaHandle = 0;
  }
  
  // Delete and Reset Pathpoints
  if (waypointHandles[0] != 0) 
  {
    for(i = 0; i < elcount(waypointHandles); i++)
    {
      C2xDeleteMapObject(waypointHandles[i]);
      waypointHandles[i] = 0;
    }
  }
  
  // Delete and Reset Text for Pathpoints
  if (waypointHandlesText[0] != 0) 
  {
    for(i = 0; i < elcount(waypointHandlesText); i++)
    {
      C2xDeleteMapObject(waypointHandlesText[i]);
      waypointHandlesText[i] = 0;
    }
  }
  
  //Delete and Reset EventImage
  if(rwwImgHandle != 0)
  {
    C2xDeleteMapObject(rwwImgHandle);
    rwwImgHandle = 0;
  }
  
  if (rsuHandle != 0)
  {
    C2xDeleteMapObject(rsuHandle);
    rsuHandle = 0;
  }
}
