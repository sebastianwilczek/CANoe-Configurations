/*@!Encoding:1252*/
/*
//  (c) Vector Informatik GmbH. All rights reserved.
//
//  This file contains definitions of structs and methods that may be used
//  to set and get the values of an ASN.1 defined packet's payload.
//
//  //This example demonstrates how to set a packet's payload:
//  LONG packetHandle;
//  struct MAP payload;
//  //you need to set the values of the variable "payload" yourself
//  packetHandle = API_InitMAPPacket();
//  if (packetHandle!=0) {
//    if (API_SetMAPParams(packetHandle, payload)==0) {
//      if (C2xCompletePacket(packetHandle)==0) {
//        C2xOutputPacket(packetHandle);
//      }
//    }
//  }
//                                                                             */
includes
{

}
variables
{
    const int sizeMAPDSRC_NodeXY = 20;                      // Original size is 63, but compilation time is very high with this value. Recommended val is 20
                                                            // Path in MAP: map.intersections.DSRC_IntersectionGeometry.laneSet.DSRC_GenericLane.nodeList.nodes                                                       
  
    const int sizeMAPDSRC_GenericLane = 40;                 // Original size is 255, but compilation time is very high with this value. Recommended val is 40
                                                            // Path in MAP: map.intersections.DSRC_IntersectionGeometry.laneSet
  
    const int sizeMAPDSRC_IntersectionGeometry = 4;         // Original size is 32, but compilation time is very high with this value. Recommended val is 4
                                                            // Path in MAP: map.intersections.DSRC_IntersectionGeometry
  
    const int sizeMAPDSRC_RestrictionClassAssignment = 10;  // Original size is 254, but compilation time is very high with this value. Recommended val is 10
                                                            // Path in MAP: map.restrictionList.DSRC_RestrictionClassAssignment
    
    struct MAPITS_Container_ItsPduHeader {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE protocolVersion;  // INTEGER, 0..255;
        BYTE messageID;  // INTEGER, 0..255, denm(1), cam(2), poi(3), spat(4), map(5), ivi(6), ev_rsr(7), tistpgtransaction(8), srem(9), ssem(10), evcsn(11), saem(12), rtcmem(13);
        DWORD stationID;  // INTEGER, 0..4294967295;
    };
    
    struct MAPDSRC_DescriptiveName {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[64];
        INT  stringLength;
    };
    
    struct MAPDSRC_IntersectionReferenceID {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_WORD_ASN region;  // INTEGER, OPTIONAL, 0..65535;
        WORD id;  // INTEGER, 0..65535;
    };
    
    struct MAPITS_Container_Altitude {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG altitudeValue;  // INTEGER, -100000..800001, referenceEllipsoidSurface(0), oneCentimeter(1), unavailable(800001);
        INT altitudeConfidence;  // ENUMERATED, alt_000_01(0), alt_000_02(1), alt_000_05(2), alt_000_10(3), alt_000_20(4), alt_000_50(5), alt_001_00(6), alt_002_00(7), alt_005_00(8), alt_010_00(9), alt_020_00(10), alt_050_00(11), alt_100_00(12), alt_200_00(13), outOfRange(14), unavailable(15);
    };
    
    struct MAPAddGrpC_Position3D_addGrpC {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAPITS_Container_Altitude altitude;  // SEQUENCE;
    };
    
    struct MAPReg_Position3D {
        struct MAPAddGrpC_Position3D_addGrpC addGrpC;  // SEQUENCE;
    };
    
    struct MAPDSRC_RegionalExtensionPosition3D {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct MAPReg_Position3D regExtValue;  // TABLE;
    };
    
    struct MAPDSRC_Position3D_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPDSRC_RegionalExtensionPosition3D arrayValue[4];  // SEQUENCE;
    };
    
    struct MAPDSRC_Position3D {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG lat;  // INTEGER, -900000000..900000001, unavailable(900000001);
        LONG lon;  // INTEGER, -1800000000..1800000001, unavailable(1800000001);
        struct OPT_LONG_ASN elevation;  // INTEGER, OPTIONAL, -4096..61439;
        struct MAPDSRC_Position3D_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct MAPDSRC_RegulatorySpeedLimit {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT type;  // ENUMERATED, unknown(0), maxSpeedInSchoolZone(1), maxSpeedInSchoolZoneWhenChildrenArePresent(2), maxSpeedInConstructionZone(3), vehicleMinSpeed(4), vehicleMaxSpeed(5), vehicleNightMaxSpeed(6), truckMinSpeed(7), truckMaxSpeed(8), truckNightMaxSpeed(9), vehiclesWithTrailersMinSpeed(10), vehiclesWithTrailersMaxSpeed(11), vehiclesWithTrailersNightMaxSpeed(12);
        WORD speed;  // INTEGER, 0..8191;
    };
    
    struct MAPDSRC_SpeedLimitList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPDSRC_RegulatorySpeedLimit arrayValue[9];  // SEQUENCE;
    };
    
    struct MAPDSRC_LaneDirection {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[3];
        INT  stringLength;
    };
    
    struct MAPDSRC_LaneSharing {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[11];
        INT  stringLength;
    };
    
    struct MAPDSRC_LaneAttributes_Vehicle {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[9];
        INT  stringLength;
    };
    
    struct MAPDSRC_LaneAttributes_Crosswalk {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct MAPDSRC_LaneAttributes_Bike {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct MAPDSRC_LaneAttributes_Sidewalk {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct MAPDSRC_LaneAttributes_Barrier {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct MAPDSRC_LaneAttributes_Striping {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct MAPDSRC_LaneAttributes_TrackedVehicle {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct MAPDSRC_LaneAttributes_Parking {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct MAPDSRC_LaneTypeAttributes {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        struct MAPDSRC_LaneAttributes_Vehicle vehicle;  // BITSTRING;
        struct MAPDSRC_LaneAttributes_Crosswalk crosswalk;  // BITSTRING;
        struct MAPDSRC_LaneAttributes_Bike bikeLane;  // BITSTRING;
        struct MAPDSRC_LaneAttributes_Sidewalk sidewalk;  // BITSTRING;
        struct MAPDSRC_LaneAttributes_Barrier median;  // BITSTRING;
        struct MAPDSRC_LaneAttributes_Striping striping;  // BITSTRING;
        struct MAPDSRC_LaneAttributes_TrackedVehicle trackedVehicle;  // BITSTRING;
        struct MAPDSRC_LaneAttributes_Parking parking;  // BITSTRING;
    };
    
    struct MAPReg_Empty {
    };
    
    struct MAPDSRC_RegionalExtensionEmpty {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct MAPReg_Empty regExtValue;  // TABLE;
    };
    
    struct MAPDSRC_LaneAttributes {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAPDSRC_LaneDirection directionalUse;  // BITSTRING;
        struct MAPDSRC_LaneSharing sharedWith;  // BITSTRING;
        struct MAPDSRC_LaneTypeAttributes laneType;  // CHOICE;
        struct MAPDSRC_RegionalExtensionEmpty regional;  // SEQUENCE, OPTIONAL;
    };
    
    struct MAPDSRC_AllowedManeuvers {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[13];
        INT  stringLength;
    };
    
    struct MAPDSRC_Node_XY_20b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -512..511;
        INT y;  // INTEGER, -512..511;
    };
    
    struct MAPDSRC_Node_XY_22b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -1024..1023;
        INT y;  // INTEGER, -1024..1023;
    };
    
    struct MAPDSRC_Node_XY_24b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -2048..2047;
        INT y;  // INTEGER, -2048..2047;
    };
    
    struct MAPDSRC_Node_XY_26b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -4096..4095;
        INT y;  // INTEGER, -4096..4095;
    };
    
    struct MAPDSRC_Node_XY_28b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -8192..8191;
        INT y;  // INTEGER, -8192..8191;
    };
    
    struct MAPDSRC_Node_XY_32b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -32768..32767;
        INT y;  // INTEGER, -32768..32767;
    };
    
    struct MAPDSRC_Node_LLmD_64b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG lon;  // INTEGER, -1800000000..1800000001, unavailable(1800000001);
        LONG lat;  // INTEGER, -900000000..900000001, unavailable(900000001);
    };
    
    struct MAPDSRC_NodeOffsetPointXY {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        struct MAPDSRC_Node_XY_20b node_XY1;  // SEQUENCE;
        struct MAPDSRC_Node_XY_22b node_XY2;  // SEQUENCE;
        struct MAPDSRC_Node_XY_24b node_XY3;  // SEQUENCE;
        struct MAPDSRC_Node_XY_26b node_XY4;  // SEQUENCE;
        struct MAPDSRC_Node_XY_28b node_XY5;  // SEQUENCE;
        struct MAPDSRC_Node_XY_32b node_XY6;  // SEQUENCE;
        struct MAPDSRC_Node_LLmD_64b node_LatLon;  // SEQUENCE;
        struct MAPDSRC_RegionalExtensionEmpty regional;  // SEQUENCE;
    };
    
    struct MAPDSRC_NodeAttributeXYList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        INT arrayValue[8];  // ENUMERATED, reserved(0), stopLine(1), roundedCapStyleA(2), roundedCapStyleB(3), mergePoint(4), divergePoint(5), downstreamStopLine(6), downstreamStartNode(7), closedToTraffic(8), safeIsland(9), curbPresentAtStepOff(10), hydrantPresent(11);
    };
    
    struct MAPDSRC_SegmentAttributeXYList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        INT arrayValue[8];  // ENUMERATED, reserved(0), doNotBlock(1), whiteLine(2), mergingLaneLeft(3), mergingLaneRight(4), curbOnLeft(5), curbOnRight(6), loadingzoneOnLeft(7), loadingzoneOnRight(8), turnOutPointOnLeft(9), turnOutPointOnRight(10), adjacentParkingOnLeft(11), adjacentParkingOnRight(12), adjacentBikeLaneOnLeft(13), adjacentBikeLaneOnRight(14), sharedBikeLane(15), bikeBoxInFront(16), transitStopOnLeft(17), transitStopOnRight(18), transitStopInLane(19), sharedWithTrackedVehicle(20), safeIsland(21), lowCurbsPresent(22), rumbleStripPresent(23), audibleSignalingPresent(24), adaptiveTimingPresent(25), rfSignalRequestPresent(26), partialCurbIntrusion(27), taperToLeft(28), taperToRight(29), taperToCenterLine(30), parallelParking(31), headInParking(32), freeParking(33), timeRestrictionsOnParking(34), costToPark(35), midBlockCurbPresent(36), unEvenPavementPresent(37);
    };
    
    struct MAPDSRC_LaneDataAttribute_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPDSRC_RegionalExtensionEmpty arrayValue[4];  // SEQUENCE;
    };
    
    struct MAPDSRC_LaneDataAttribute {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        INT pathEndPointAngle;  // INTEGER, -150..150;
        INT laneCrownPointCenter;  // INTEGER, -128..127;
        INT laneCrownPointLeft;  // INTEGER, -128..127;
        INT laneCrownPointRight;  // INTEGER, -128..127;
        INT laneAngle;  // INTEGER, -180..180;
        struct MAPDSRC_SpeedLimitList speedLimits;  // SEQUENCEOF;
        struct MAPDSRC_LaneDataAttribute_regional regional;  // SEQUENCEOF;
    };
    
    struct MAPDSRC_LaneDataAttributeList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPDSRC_LaneDataAttribute arrayValue[8];  // CHOICE;
    };
    
    struct MAPAddGrpC_Control_addGrpC {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT ptvRequest;  // ENUMERATED, preRequest(0), mainRequest(1), doorCloseRequest(2), cancelRequest(3), emergencyRequest(4);
    };
    
    struct MAPReg_NodeAttributeSetXY {
        struct MAPAddGrpC_Control_addGrpC addGrpC;  // SEQUENCE;
    };
    
    struct MAPDSRC_RegionalExtensionNodeAttributeSetXY {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct MAPReg_NodeAttributeSetXY regExtValue;  // TABLE;
    };
    
    struct MAPDSRC_NodeAttributeSetXY_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPDSRC_RegionalExtensionNodeAttributeSetXY arrayValue[4];  // SEQUENCE;
    };
    
    struct MAPDSRC_NodeAttributeSetXY {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAPDSRC_NodeAttributeXYList localNode;  // SEQUENCEOF, OPTIONAL;
        struct MAPDSRC_SegmentAttributeXYList disabled;  // SEQUENCEOF, OPTIONAL;
        struct MAPDSRC_SegmentAttributeXYList enabled;  // SEQUENCEOF, OPTIONAL;
        struct MAPDSRC_LaneDataAttributeList data;  // SEQUENCEOF, OPTIONAL;
        struct OPT_INT_ASN dWidth;  // INTEGER, OPTIONAL, -512..511;
        struct OPT_INT_ASN dElevation;  // INTEGER, OPTIONAL, -512..511;
        struct MAPDSRC_NodeAttributeSetXY_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct MAPDSRC_NodeXY {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAPDSRC_NodeOffsetPointXY delta;  // CHOICE;
        struct MAPDSRC_NodeAttributeSetXY attributes;  // SEQUENCE, OPTIONAL;
    };
    
    struct MAPDSRC_NodeSetXY {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPDSRC_NodeXY arrayValue[sizeMAPDSRC_NodeXY];  // SEQUENCE;
    };
    
    struct MAPDSRC_ComputedLane_offsetXaxis {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        INT small;  // INTEGER, -2047..2047;
        INT large;  // INTEGER, -32767..32767;
    };
    
    struct MAPDSRC_ComputedLane_offsetYaxis {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        INT small;  // INTEGER, -2047..2047;
        INT large;  // INTEGER, -32767..32767;
    };
    
    struct MAPDSRC_ComputedLane_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPDSRC_RegionalExtensionEmpty arrayValue[4];  // SEQUENCE;
    };
    
    struct MAPDSRC_ComputedLane {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE referenceLaneId;  // INTEGER, 0..255;
        struct MAPDSRC_ComputedLane_offsetXaxis offsetXaxis;  // CHOICE;
        struct MAPDSRC_ComputedLane_offsetYaxis offsetYaxis;  // CHOICE;
        struct OPT_WORD_ASN rotateXY;  // INTEGER, OPTIONAL, 0..28800;
        struct OPT_INT_ASN scaleXaxis;  // INTEGER, OPTIONAL, -2048..2047;
        struct OPT_INT_ASN scaleYaxis;  // INTEGER, OPTIONAL, -2048..2047;
        struct MAPDSRC_ComputedLane_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct MAPDSRC_NodeListXY {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        struct MAPDSRC_NodeSetXY nodes;  // SEQUENCEOF;
        struct MAPDSRC_ComputedLane computed;  // SEQUENCE;
    };
    
    struct MAPDSRC_ConnectingLane {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE lane;  // INTEGER, 0..255;
        struct MAPDSRC_AllowedManeuvers maneuver;  // BITSTRING, OPTIONAL;
    };
    
    struct MAPDSRC_Connection {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAPDSRC_ConnectingLane connectingLane;  // SEQUENCE;
        struct MAPDSRC_IntersectionReferenceID remoteIntersection;  // SEQUENCE, OPTIONAL;
        struct OPT_BYTE_ASN signalGroup;  // INTEGER, OPTIONAL, 0..255;
        struct OPT_BYTE_ASN userClass;  // INTEGER, OPTIONAL, 0..255;
        struct OPT_BYTE_ASN connectionID;  // INTEGER, OPTIONAL, 0..255;
    };
    
    struct MAPDSRC_ConnectsToList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPDSRC_Connection arrayValue[16];  // SEQUENCE;
    };
    
    struct MAPDSRC_OverlayLaneList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        BYTE arrayValue[5];  // INTEGER, 0..255;
    };
    
    struct MAPAddGrpC_ConnectionTrajectory_addGrpC {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAPDSRC_NodeSetXY nodes;  // SEQUENCEOF;
    };
    
    struct MAPReg_GenericLane {
        struct MAPAddGrpC_ConnectionTrajectory_addGrpC addGrpC;  // SEQUENCE;
    };
    
    struct MAPDSRC_RegionalExtensionGenericLane {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct MAPReg_GenericLane regExtValue;  // TABLE;
    };
    
    struct MAPDSRC_GenericLane_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPDSRC_RegionalExtensionGenericLane arrayValue[4];  // SEQUENCE;
    };
    
    struct MAPDSRC_GenericLane {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE laneID;  // INTEGER, 0..255;
        struct MAPDSRC_DescriptiveName name;  // IA5STRING, OPTIONAL;
        struct OPT_BYTE_ASN ingressApproach;  // INTEGER, OPTIONAL, 0..15;
        struct OPT_BYTE_ASN egressApproach;  // INTEGER, OPTIONAL, 0..15;
        struct MAPDSRC_LaneAttributes laneAttributes;  // SEQUENCE;
        struct MAPDSRC_AllowedManeuvers maneuvers;  // BITSTRING, OPTIONAL;
        struct MAPDSRC_NodeListXY nodeList;  // CHOICE;
        struct MAPDSRC_ConnectsToList connectsTo;  // SEQUENCEOF, OPTIONAL;
        struct MAPDSRC_OverlayLaneList overlays;  // SEQUENCEOF, OPTIONAL;
        struct MAPDSRC_GenericLane_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct MAPDSRC_LaneList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPDSRC_GenericLane arrayValue[sizeMAPDSRC_GenericLane];  // SEQUENCE;
    };
    
    struct MAPDSRC_SignalControlZone {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAPDSRC_RegionalExtensionEmpty zone;  // SEQUENCE;
    };
    
    struct MAPDSRC_PreemptPriorityList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPDSRC_SignalControlZone arrayValue[32];  // SEQUENCE;
    };
    
    struct MAPDSRC_IntersectionGeometry_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPDSRC_RegionalExtensionEmpty arrayValue[4];  // SEQUENCE;
    };
    
    struct MAPDSRC_IntersectionGeometry {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAPDSRC_DescriptiveName name;  // IA5STRING, OPTIONAL;
        struct MAPDSRC_IntersectionReferenceID id;  // SEQUENCE;
        BYTE revision;  // INTEGER, 0..127;
        struct MAPDSRC_Position3D refPoint;  // SEQUENCE;
        struct OPT_WORD_ASN laneWidth;  // INTEGER, OPTIONAL, 0..32767;
        struct MAPDSRC_SpeedLimitList speedLimits;  // SEQUENCEOF, OPTIONAL;
        struct MAPDSRC_LaneList laneSet;  // SEQUENCEOF;
        struct MAPDSRC_PreemptPriorityList preemptPriorityData;  // SEQUENCEOF, OPTIONAL;
        struct MAPDSRC_IntersectionGeometry_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct MAPDSRC_IntersectionGeometryList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPDSRC_IntersectionGeometry arrayValue[sizeMAPDSRC_IntersectionGeometry];  // SEQUENCE;
    };
    
    struct MAPDSRC_RoadSegmentReferenceID {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_WORD_ASN region;  // INTEGER, OPTIONAL, 0..65535;
        WORD id;  // INTEGER, 0..65535;
    };
    
    struct MAPDSRC_RoadLaneSetList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPDSRC_GenericLane arrayValue[sizeMAPDSRC_GenericLane];  // SEQUENCE;
    };
    
    struct MAPDSRC_RoadSegment_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPDSRC_RegionalExtensionEmpty arrayValue[4];  // SEQUENCE;
    };
    
    struct MAPDSRC_RoadSegment {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAPDSRC_DescriptiveName name;  // IA5STRING, OPTIONAL;
        struct MAPDSRC_RoadSegmentReferenceID id;  // SEQUENCE;
        BYTE revision;  // INTEGER, 0..127;
        struct MAPDSRC_Position3D refPoint;  // SEQUENCE;
        struct OPT_WORD_ASN laneWidth;  // INTEGER, OPTIONAL, 0..32767;
        struct MAPDSRC_SpeedLimitList speedLimits;  // SEQUENCEOF, OPTIONAL;
        struct MAPDSRC_RoadLaneSetList roadLaneSet;  // SEQUENCEOF;
        struct MAPDSRC_RoadSegment_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct MAPDSRC_RoadSegmentList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPDSRC_RoadSegment arrayValue[32];  // SEQUENCE;
    };
    
    struct MAPDSRC_DataParameters_processMethod {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[256];
        INT  stringLength;
    };
    
    struct MAPDSRC_DataParameters_processAgency {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[256];
        INT  stringLength;
    };
    
    struct MAPDSRC_DataParameters_lastCheckedDate {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[256];
        INT  stringLength;
    };
    
    struct MAPDSRC_DataParameters_geoidUsed {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[256];
        INT  stringLength;
    };
    
    struct MAPDSRC_DataParameters {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAPDSRC_DataParameters_processMethod processMethod;  // IA5STRING, OPTIONAL;
        struct MAPDSRC_DataParameters_processAgency processAgency;  // IA5STRING, OPTIONAL;
        struct MAPDSRC_DataParameters_lastCheckedDate lastCheckedDate;  // IA5STRING, OPTIONAL;
        struct MAPDSRC_DataParameters_geoidUsed geoidUsed;  // IA5STRING, OPTIONAL;
    };
    
    struct MAPAddGrpC_RestrictionUserType_addGrpC {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_ENUM_ASN emission;  // ENUMERATED, OPTIONAL, euro1(0), euro2(1), euro3(2), euro4(3), euro5(4), euro6(5);
    };
    
    struct MAPReg_RestrictionUserType {
        struct MAPAddGrpC_RestrictionUserType_addGrpC addGrpC;  // SEQUENCE;
    };
    
    struct MAPDSRC_RegionalExtensionRestrictionUserType {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct MAPReg_RestrictionUserType regExtValue;  // TABLE;
    };
    
    struct MAPDSRC_RestrictionUserType_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPDSRC_RegionalExtensionRestrictionUserType arrayValue[4];  // SEQUENCE;
    };
    
    struct MAPDSRC_RestrictionUserType {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        INT basicType;  // ENUMERATED, none(0), equippedTransit(1), equippedTaxis(2), equippedOther(3), emissionCompliant(4), equippedBicycle(5), weightCompliant(6), heightCompliant(7), pedestrians(8), slowMovingPersons(9), wheelchairUsers(10), visualDisabilities(11), audioDisabilities(12), otherUnknownDisabilities(13);
        struct MAPDSRC_RestrictionUserType_regional regional;  // SEQUENCEOF;
    };
    
    struct MAPDSRC_RestrictionUserTypeList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPDSRC_RestrictionUserType arrayValue[16];  // CHOICE;
    };
    
    struct MAPDSRC_RestrictionClassAssignment {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE id;  // INTEGER, 0..255;
        struct MAPDSRC_RestrictionUserTypeList users;  // SEQUENCEOF;
    };
    
    struct MAPDSRC_RestrictionClassList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPDSRC_RestrictionClassAssignment arrayValue[sizeMAPDSRC_RestrictionClassAssignment];  // SEQUENCE;
    };
    
    struct MAPDSRC_RegionalExtensionMapData {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
    };
    
    struct MAPDSRC_MapData_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPDSRC_RegionalExtensionMapData arrayValue[4];  // SEQUENCE;
    };
    
    struct MAPDSRC_MapData {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_DWORD_ASN timeStamp;  // INTEGER, OPTIONAL, 0..527040;
        BYTE msgIssueRevision;  // INTEGER, 0..127;
        struct OPT_ENUM_ASN layerType;  // ENUMERATED, OPTIONAL, none(0), mixedContent(1), generalMapData(2), intersectionData(3), curveData(4), roadwaySectionData(5), parkingAreaData(6), sharedLaneData(7);
        struct OPT_BYTE_ASN layerID;  // INTEGER, OPTIONAL, 0..100;
        struct MAPDSRC_IntersectionGeometryList intersections;  // SEQUENCEOF, OPTIONAL;
        struct MAPDSRC_RoadSegmentList roadSegments;  // SEQUENCEOF, OPTIONAL;
        struct MAPDSRC_DataParameters dataParameters;  // SEQUENCE, OPTIONAL;
        struct MAPDSRC_RestrictionClassList restrictionList;  // SEQUENCEOF, OPTIONAL;
        struct MAPDSRC_MapData_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct MAP {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAPITS_Container_ItsPduHeader header;  // SEQUENCE;
        struct MAPDSRC_MapData map;  // SEQUENCE;
    };
    
}

/*
// init function to create a simple packet handle
*/ 
LONG API_InitMAPPacket()
{
  return C2xInitPacket("MAP"); 
}

/*
// init function to create a simple packet handle and
// initialize the struct with valid data
*/ 
LONG API_InitMAPPacket(struct MAP msgStruct)
{
  long pktHandle;

  pktHandle = API_InitMAPPacket();

  if (pktHandle != 0)
  {
    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      API_GetMAPParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}

/*
// init function to create a packet with security layer and
// initialize the struct with valid data
*/ 
LONG API_InitMAPPacket(struct MAP msgStruct, char packetTypeDesignator[], char certificateName[])
{
  long pktHandle, certHdl;

  // initialize the packet
  pktHandle = C2xInitPacket("MAP", packetTypeDesignator);

  if (pktHandle != 0)
  {
    certHdl = C2xSecCertificateGetHandle(certificateName);  // get the certificate handle for the cert with name "certificateName"
    if (certHdl != 0) 
    {
      C2xSecPacketSetSignerHandle(pktHandle, certHdl); // set the certHdl to the packet
    }

    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      // copy application data to the application structure
      API_GetMAPParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}
    

int GetMAPITS_Container_ItsPduHeaderParams(LONG packetHandle, struct MAPITS_Container_ItsPduHeader value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "protocolVersion");
  value.protocolVersion = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "messageID");
  value.messageID = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationID");
  value.stationID = C2xGetTokenInt64(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPITS_Container_ItsPduHeaderParams(LONG packetHandle, struct MAPITS_Container_ItsPduHeader value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "protocolVersion");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.protocolVersion);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "messageID");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.messageID);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationID");
  C2xSetTokenInt64(packetHandle, "MAP", newPath, value.stationID);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPDSRC_IntersectionReferenceIDParams(LONG packetHandle, struct MAPDSRC_IntersectionReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  value.region.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.region.isValidFlag==1)
  {
    value.region.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  value.id = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPDSRC_IntersectionReferenceIDParams(LONG packetHandle, struct MAPDSRC_IntersectionReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  if(value.region.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.region.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.id);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPITS_Container_AltitudeParams(LONG packetHandle, struct MAPITS_Container_Altitude value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "altitudeValue");
  value.altitudeValue = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "altitudeConfidence");
  value.altitudeConfidence = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPITS_Container_AltitudeParams(LONG packetHandle, struct MAPITS_Container_Altitude value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "altitudeValue");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.altitudeValue);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "altitudeConfidence");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.altitudeConfidence);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPAddGrpC_Position3D_addGrpCParams(LONG packetHandle, struct MAPAddGrpC_Position3D_addGrpC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "altitude");
  GetMAPITS_Container_AltitudeParams(packetHandle, value.altitude, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPAddGrpC_Position3D_addGrpCParams(LONG packetHandle, struct MAPAddGrpC_Position3D_addGrpC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "altitude");
  SetMAPITS_Container_AltitudeParams(packetHandle, value.altitude, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPReg_Position3DParams(LONG packetHandle, WORD tableKey, struct MAPReg_Position3D value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpC");
      GetMAPAddGrpC_Position3D_addGrpCParams(packetHandle, value.addGrpC, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAPReg_Position3DParams(LONG packetHandle, WORD tableKey, struct MAPReg_Position3D value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpC");
      SetMAPAddGrpC_Position3D_addGrpCParams(packetHandle, value.addGrpC, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAPDSRC_RegionalExtensionPosition3DParams(LONG packetHandle, struct MAPDSRC_RegionalExtensionPosition3D value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  GetMAPReg_Position3DParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPDSRC_RegionalExtensionPosition3DParams(LONG packetHandle, struct MAPDSRC_RegionalExtensionPosition3D value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  SetMAPReg_Position3DParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPDSRC_Position3D_regionalParams(LONG packetHandle, struct MAPDSRC_Position3D_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPDSRC_RegionalExtensionPosition3DParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPDSRC_Position3D_regionalParams(LONG packetHandle, struct MAPDSRC_Position3D_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPDSRC_RegionalExtensionPosition3DParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPDSRC_Position3DParams(LONG packetHandle, struct MAPDSRC_Position3D value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevation");
  value.elevation.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.elevation.isValidFlag==1)
  {
    value.elevation.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetMAPDSRC_Position3D_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPDSRC_Position3DParams(LONG packetHandle, struct MAPDSRC_Position3D value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.lat);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.lon);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevation");
  if(value.elevation.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.elevation.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetMAPDSRC_Position3D_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPDSRC_RegulatorySpeedLimitParams(LONG packetHandle, struct MAPDSRC_RegulatorySpeedLimit value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "type");
  value.type = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  value.speed = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPDSRC_RegulatorySpeedLimitParams(LONG packetHandle, struct MAPDSRC_RegulatorySpeedLimit value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "type");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.type);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.speed);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPDSRC_SpeedLimitListParams(LONG packetHandle, struct MAPDSRC_SpeedLimitList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPDSRC_RegulatorySpeedLimitParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPDSRC_SpeedLimitListParams(LONG packetHandle, struct MAPDSRC_SpeedLimitList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPDSRC_RegulatorySpeedLimitParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPDSRC_LaneTypeAttributesParams(LONG packetHandle, struct MAPDSRC_LaneTypeAttributes value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "MAP", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vehicle");
      value.vehicle.isValidFlag = 1;
      value.vehicle.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
      if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.vehicle.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
          {
            value.vehicle.string[j] = '0';
          }
          else
          {
            value.vehicle.string[j] = '1';
          }
          result = CheckLastError("MAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "crosswalk");
      value.crosswalk.isValidFlag = 1;
      value.crosswalk.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
      if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.crosswalk.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
          {
            value.crosswalk.string[j] = '0';
          }
          else
          {
            value.crosswalk.string[j] = '1';
          }
          result = CheckLastError("MAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "bikeLane");
      value.bikeLane.isValidFlag = 1;
      value.bikeLane.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
      if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.bikeLane.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
          {
            value.bikeLane.string[j] = '0';
          }
          else
          {
            value.bikeLane.string[j] = '1';
          }
          result = CheckLastError("MAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sidewalk");
      value.sidewalk.isValidFlag = 1;
      value.sidewalk.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
      if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.sidewalk.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
          {
            value.sidewalk.string[j] = '0';
          }
          else
          {
            value.sidewalk.string[j] = '1';
          }
          result = CheckLastError("MAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "median");
      value.median.isValidFlag = 1;
      value.median.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
      if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.median.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
          {
            value.median.string[j] = '0';
          }
          else
          {
            value.median.string[j] = '1';
          }
          result = CheckLastError("MAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "striping");
      value.striping.isValidFlag = 1;
      value.striping.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
      if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.striping.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
          {
            value.striping.string[j] = '0';
          }
          else
          {
            value.striping.string[j] = '1';
          }
          result = CheckLastError("MAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "trackedVehicle");
      value.trackedVehicle.isValidFlag = 1;
      value.trackedVehicle.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
      if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.trackedVehicle.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
          {
            value.trackedVehicle.string[j] = '0';
          }
          else
          {
            value.trackedVehicle.string[j] = '1';
          }
          result = CheckLastError("MAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 7:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "parking");
      value.parking.isValidFlag = 1;
      value.parking.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
      if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.parking.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
          {
            value.parking.string[j] = '0';
          }
          else
          {
            value.parking.string[j] = '1';
          }
          result = CheckLastError("MAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAPDSRC_LaneTypeAttributesParams(LONG packetHandle, struct MAPDSRC_LaneTypeAttributes value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vehicle");
      for(j=0; j<value.vehicle.stringLength; j++)
      {
        if(value.vehicle.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "crosswalk");
      for(j=0; j<value.crosswalk.stringLength; j++)
      {
        if(value.crosswalk.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "bikeLane");
      for(j=0; j<value.bikeLane.stringLength; j++)
      {
        if(value.bikeLane.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sidewalk");
      for(j=0; j<value.sidewalk.stringLength; j++)
      {
        if(value.sidewalk.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "median");
      for(j=0; j<value.median.stringLength; j++)
      {
        if(value.median.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "striping");
      for(j=0; j<value.striping.stringLength; j++)
      {
        if(value.striping.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "trackedVehicle");
      for(j=0; j<value.trackedVehicle.stringLength; j++)
      {
        if(value.trackedVehicle.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 7:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "parking");
      for(j=0; j<value.parking.stringLength; j++)
      {
        if(value.parking.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAPDSRC_RegionalExtensionEmptyParams(LONG packetHandle, struct MAPDSRC_RegionalExtensionEmpty value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPDSRC_RegionalExtensionEmptyParams(LONG packetHandle, struct MAPDSRC_RegionalExtensionEmpty value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  return result;
}

int GetMAPDSRC_LaneAttributesParams(LONG packetHandle, struct MAPDSRC_LaneAttributes value, char oldPath[])
{
  char newPath[300]; 
  int j; 
  int k;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "directionalUse");
  value.directionalUse.isValidFlag = 1;
  value.directionalUse.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
  if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    if(value.directionalUse.stringLength > 0)
    {
      for(j=0; j<value.directionalUse.stringLength; j++)
      {
        if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
        {
          value.directionalUse.string[j] = '0';
        }
        else if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 1)
        {
          value.directionalUse.string[j] = '1';
        }

        if(value.directionalUse.stringLength == 1)
        {
          value.directionalUse.string[1] = '0';
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
    }
    else
    {
      for(k = value.directionalUse.stringLength+1; k > -1; k--)
      {
        if(value.directionalUse.string[k] == '1')
        {
          value.directionalUse.string[k] = '0';
        }
      }
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sharedWith");
  value.sharedWith.isValidFlag = 1;
  value.sharedWith.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
  if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    if(value.sharedWith.stringLength > 0)
    {
      for(j=0; j<value.sharedWith.stringLength; j++)
      {
        if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
        {
          value.sharedWith.string[j] = '0';
        }
        else if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 1)
        {
          value.sharedWith.string[j] = '1';
        }

        if(value.sharedWith.stringLength == 1)
        {
          value.sharedWith.string[1] = '0';
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
    }
    else
    {
      for(k = value.sharedWith.stringLength+1; k > -1; k--)
      {
        if(value.sharedWith.string[k] == '1')
        {
          value.sharedWith.string[k] = '0';
        }
      }
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneType");
  GetMAPDSRC_LaneTypeAttributesParams(packetHandle, value.laneType, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetMAPDSRC_RegionalExtensionEmptyParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPDSRC_LaneAttributesParams(LONG packetHandle, struct MAPDSRC_LaneAttributes value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "directionalUse");
    for(j=0; j<value.directionalUse.stringLength; j++)
    {
      if(value.directionalUse.string[j] == '0')
      {
        C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
      }
      else
      {
        C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
      }
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sharedWith");
    for(j=0; j<value.sharedWith.stringLength; j++)
    {
      if(value.sharedWith.string[j] == '0')
      {
        C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
      }
      else
      {
        C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
      }
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneType");
  SetMAPDSRC_LaneTypeAttributesParams(packetHandle, value.laneType, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetMAPDSRC_RegionalExtensionEmptyParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPDSRC_Node_XY_20bParams(LONG packetHandle, struct MAPDSRC_Node_XY_20b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPDSRC_Node_XY_20bParams(LONG packetHandle, struct MAPDSRC_Node_XY_20b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.x);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.y);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPDSRC_Node_XY_22bParams(LONG packetHandle, struct MAPDSRC_Node_XY_22b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPDSRC_Node_XY_22bParams(LONG packetHandle, struct MAPDSRC_Node_XY_22b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.x);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.y);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPDSRC_Node_XY_24bParams(LONG packetHandle, struct MAPDSRC_Node_XY_24b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPDSRC_Node_XY_24bParams(LONG packetHandle, struct MAPDSRC_Node_XY_24b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.x);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.y);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPDSRC_Node_XY_26bParams(LONG packetHandle, struct MAPDSRC_Node_XY_26b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPDSRC_Node_XY_26bParams(LONG packetHandle, struct MAPDSRC_Node_XY_26b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.x);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.y);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPDSRC_Node_XY_28bParams(LONG packetHandle, struct MAPDSRC_Node_XY_28b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPDSRC_Node_XY_28bParams(LONG packetHandle, struct MAPDSRC_Node_XY_28b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.x);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.y);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPDSRC_Node_XY_32bParams(LONG packetHandle, struct MAPDSRC_Node_XY_32b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPDSRC_Node_XY_32bParams(LONG packetHandle, struct MAPDSRC_Node_XY_32b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.x);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.y);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPDSRC_Node_LLmD_64bParams(LONG packetHandle, struct MAPDSRC_Node_LLmD_64b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPDSRC_Node_LLmD_64bParams(LONG packetHandle, struct MAPDSRC_Node_LLmD_64b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.lon);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.lat);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPDSRC_NodeOffsetPointXYParams(LONG packetHandle, struct MAPDSRC_NodeOffsetPointXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "MAP", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY1");
      GetMAPDSRC_Node_XY_20bParams(packetHandle, value.node_XY1, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY2");
      GetMAPDSRC_Node_XY_22bParams(packetHandle, value.node_XY2, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY3");
      GetMAPDSRC_Node_XY_24bParams(packetHandle, value.node_XY3, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY4");
      GetMAPDSRC_Node_XY_26bParams(packetHandle, value.node_XY4, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY5");
      GetMAPDSRC_Node_XY_28bParams(packetHandle, value.node_XY5, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY6");
      GetMAPDSRC_Node_XY_32bParams(packetHandle, value.node_XY6, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_LatLon");
      GetMAPDSRC_Node_LLmD_64bParams(packetHandle, value.node_LatLon, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 7:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
      GetMAPDSRC_RegionalExtensionEmptyParams(packetHandle, value.regional, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAPDSRC_NodeOffsetPointXYParams(LONG packetHandle, struct MAPDSRC_NodeOffsetPointXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY1");
      SetMAPDSRC_Node_XY_20bParams(packetHandle, value.node_XY1, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY2");
      SetMAPDSRC_Node_XY_22bParams(packetHandle, value.node_XY2, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY3");
      SetMAPDSRC_Node_XY_24bParams(packetHandle, value.node_XY3, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY4");
      SetMAPDSRC_Node_XY_26bParams(packetHandle, value.node_XY4, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY5");
      SetMAPDSRC_Node_XY_28bParams(packetHandle, value.node_XY5, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY6");
      SetMAPDSRC_Node_XY_32bParams(packetHandle, value.node_XY6, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_LatLon");
      SetMAPDSRC_Node_LLmD_64bParams(packetHandle, value.node_LatLon, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 7:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
      SetMAPDSRC_RegionalExtensionEmptyParams(packetHandle, value.regional, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAPDSRC_NodeAttributeXYListParams(LONG packetHandle, struct MAPDSRC_NodeAttributeXYList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      value.arrayValue[i] = C2xGetTokenInt64(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPDSRC_NodeAttributeXYListParams(LONG packetHandle, struct MAPDSRC_NodeAttributeXYList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    C2xSetTokenInt64(packetHandle, "MAP", newPath, value.arrayValue[i]);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPDSRC_SegmentAttributeXYListParams(LONG packetHandle, struct MAPDSRC_SegmentAttributeXYList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      value.arrayValue[i] = C2xGetTokenInt64(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPDSRC_SegmentAttributeXYListParams(LONG packetHandle, struct MAPDSRC_SegmentAttributeXYList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    C2xSetTokenInt64(packetHandle, "MAP", newPath, value.arrayValue[i]);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPDSRC_LaneDataAttribute_regionalParams(LONG packetHandle, struct MAPDSRC_LaneDataAttribute_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPDSRC_RegionalExtensionEmptyParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPDSRC_LaneDataAttribute_regionalParams(LONG packetHandle, struct MAPDSRC_LaneDataAttribute_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPDSRC_RegionalExtensionEmptyParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPDSRC_LaneDataAttributeParams(LONG packetHandle, struct MAPDSRC_LaneDataAttribute value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "MAP", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathEndPointAngle");
      value.pathEndPointAngle = C2xGetTokenInt(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneCrownPointCenter");
      value.laneCrownPointCenter = C2xGetTokenInt(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneCrownPointLeft");
      value.laneCrownPointLeft = C2xGetTokenInt(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneCrownPointRight");
      value.laneCrownPointRight = C2xGetTokenInt(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneAngle");
      value.laneAngle = C2xGetTokenInt(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimits");
      GetMAPDSRC_SpeedLimitListParams(packetHandle, value.speedLimits, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
      GetMAPDSRC_LaneDataAttribute_regionalParams(packetHandle, value.regional, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAPDSRC_LaneDataAttributeParams(LONG packetHandle, struct MAPDSRC_LaneDataAttribute value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathEndPointAngle");
      C2xSetTokenInt(packetHandle, "MAP", newPath, value.pathEndPointAngle);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneCrownPointCenter");
      C2xSetTokenInt(packetHandle, "MAP", newPath, value.laneCrownPointCenter);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneCrownPointLeft");
      C2xSetTokenInt(packetHandle, "MAP", newPath, value.laneCrownPointLeft);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneCrownPointRight");
      C2xSetTokenInt(packetHandle, "MAP", newPath, value.laneCrownPointRight);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneAngle");
      C2xSetTokenInt(packetHandle, "MAP", newPath, value.laneAngle);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimits");
      SetMAPDSRC_SpeedLimitListParams(packetHandle, value.speedLimits, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
      SetMAPDSRC_LaneDataAttribute_regionalParams(packetHandle, value.regional, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAPDSRC_LaneDataAttributeListParams(LONG packetHandle, struct MAPDSRC_LaneDataAttributeList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPDSRC_LaneDataAttributeParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPDSRC_LaneDataAttributeListParams(LONG packetHandle, struct MAPDSRC_LaneDataAttributeList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPDSRC_LaneDataAttributeParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPAddGrpC_Control_addGrpCParams(LONG packetHandle, struct MAPAddGrpC_Control_addGrpC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "ptvRequest");
  value.ptvRequest = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPAddGrpC_Control_addGrpCParams(LONG packetHandle, struct MAPAddGrpC_Control_addGrpC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "ptvRequest");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.ptvRequest);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPReg_NodeAttributeSetXYParams(LONG packetHandle, WORD tableKey, struct MAPReg_NodeAttributeSetXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpC");
      GetMAPAddGrpC_Control_addGrpCParams(packetHandle, value.addGrpC, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAPReg_NodeAttributeSetXYParams(LONG packetHandle, WORD tableKey, struct MAPReg_NodeAttributeSetXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpC");
      SetMAPAddGrpC_Control_addGrpCParams(packetHandle, value.addGrpC, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAPDSRC_RegionalExtensionNodeAttributeSetXYParams(LONG packetHandle, struct MAPDSRC_RegionalExtensionNodeAttributeSetXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  GetMAPReg_NodeAttributeSetXYParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPDSRC_RegionalExtensionNodeAttributeSetXYParams(LONG packetHandle, struct MAPDSRC_RegionalExtensionNodeAttributeSetXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  SetMAPReg_NodeAttributeSetXYParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPDSRC_NodeAttributeSetXY_regionalParams(LONG packetHandle, struct MAPDSRC_NodeAttributeSetXY_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPDSRC_RegionalExtensionNodeAttributeSetXYParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPDSRC_NodeAttributeSetXY_regionalParams(LONG packetHandle, struct MAPDSRC_NodeAttributeSetXY_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPDSRC_RegionalExtensionNodeAttributeSetXYParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPDSRC_NodeAttributeSetXYParams(LONG packetHandle, struct MAPDSRC_NodeAttributeSetXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "localNode");
  value.localNode.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.localNode.isValidFlag==1)
  {
    GetMAPDSRC_NodeAttributeXYListParams(packetHandle, value.localNode, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "disabled");
  value.disabled.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.disabled.isValidFlag==1)
  {
    GetMAPDSRC_SegmentAttributeXYListParams(packetHandle, value.disabled, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "enabled");
  value.enabled.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.enabled.isValidFlag==1)
  {
    GetMAPDSRC_SegmentAttributeXYListParams(packetHandle, value.enabled, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "data");
  value.data.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.data.isValidFlag==1)
  {
    GetMAPDSRC_LaneDataAttributeListParams(packetHandle, value.data, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "dWidth");
  value.dWidth.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.dWidth.isValidFlag==1)
  {
    value.dWidth.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "dElevation");
  value.dElevation.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.dElevation.isValidFlag==1)
  {
    value.dElevation.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetMAPDSRC_NodeAttributeSetXY_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPDSRC_NodeAttributeSetXYParams(LONG packetHandle, struct MAPDSRC_NodeAttributeSetXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "localNode");
  if(value.localNode.isValidFlag==1)
  {
    SetMAPDSRC_NodeAttributeXYListParams(packetHandle, value.localNode, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "disabled");
  if(value.disabled.isValidFlag==1)
  {
    SetMAPDSRC_SegmentAttributeXYListParams(packetHandle, value.disabled, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "enabled");
  if(value.enabled.isValidFlag==1)
  {
    SetMAPDSRC_SegmentAttributeXYListParams(packetHandle, value.enabled, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "data");
  if(value.data.isValidFlag==1)
  {
    SetMAPDSRC_LaneDataAttributeListParams(packetHandle, value.data, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "dWidth");
  if(value.dWidth.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.dWidth.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "dElevation");
  if(value.dElevation.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.dElevation.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetMAPDSRC_NodeAttributeSetXY_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPDSRC_NodeXYParams(LONG packetHandle, struct MAPDSRC_NodeXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "delta");
  GetMAPDSRC_NodeOffsetPointXYParams(packetHandle, value.delta, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "attributes");
  value.attributes.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.attributes.isValidFlag==1)
  {
    GetMAPDSRC_NodeAttributeSetXYParams(packetHandle, value.attributes, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPDSRC_NodeXYParams(LONG packetHandle, struct MAPDSRC_NodeXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "delta");
  SetMAPDSRC_NodeOffsetPointXYParams(packetHandle, value.delta, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "attributes");
  if(value.attributes.isValidFlag==1)
  {
    SetMAPDSRC_NodeAttributeSetXYParams(packetHandle, value.attributes, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPDSRC_NodeSetXYParams(LONG packetHandle, struct MAPDSRC_NodeSetXY value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPDSRC_NodeXYParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPDSRC_NodeSetXYParams(LONG packetHandle, struct MAPDSRC_NodeSetXY value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPDSRC_NodeXYParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPDSRC_ComputedLane_offsetXaxisParams(LONG packetHandle, struct MAPDSRC_ComputedLane_offsetXaxis value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "MAP", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "small");
      value.small = C2xGetTokenInt(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "large");
      value.large = C2xGetTokenInt(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAPDSRC_ComputedLane_offsetXaxisParams(LONG packetHandle, struct MAPDSRC_ComputedLane_offsetXaxis value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "small");
      C2xSetTokenInt(packetHandle, "MAP", newPath, value.small);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "large");
      C2xSetTokenInt(packetHandle, "MAP", newPath, value.large);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAPDSRC_ComputedLane_offsetYaxisParams(LONG packetHandle, struct MAPDSRC_ComputedLane_offsetYaxis value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "MAP", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "small");
      value.small = C2xGetTokenInt(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "large");
      value.large = C2xGetTokenInt(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAPDSRC_ComputedLane_offsetYaxisParams(LONG packetHandle, struct MAPDSRC_ComputedLane_offsetYaxis value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "small");
      C2xSetTokenInt(packetHandle, "MAP", newPath, value.small);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "large");
      C2xSetTokenInt(packetHandle, "MAP", newPath, value.large);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAPDSRC_ComputedLane_regionalParams(LONG packetHandle, struct MAPDSRC_ComputedLane_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPDSRC_RegionalExtensionEmptyParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPDSRC_ComputedLane_regionalParams(LONG packetHandle, struct MAPDSRC_ComputedLane_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPDSRC_RegionalExtensionEmptyParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPDSRC_ComputedLaneParams(LONG packetHandle, struct MAPDSRC_ComputedLane value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "referenceLaneId");
  value.referenceLaneId = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offsetXaxis");
  GetMAPDSRC_ComputedLane_offsetXaxisParams(packetHandle, value.offsetXaxis, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offsetYaxis");
  GetMAPDSRC_ComputedLane_offsetYaxisParams(packetHandle, value.offsetYaxis, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "rotateXY");
  value.rotateXY.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.rotateXY.isValidFlag==1)
  {
    value.rotateXY.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "scaleXaxis");
  value.scaleXaxis.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.scaleXaxis.isValidFlag==1)
  {
    value.scaleXaxis.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "scaleYaxis");
  value.scaleYaxis.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.scaleYaxis.isValidFlag==1)
  {
    value.scaleYaxis.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetMAPDSRC_ComputedLane_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPDSRC_ComputedLaneParams(LONG packetHandle, struct MAPDSRC_ComputedLane value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "referenceLaneId");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.referenceLaneId);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offsetXaxis");
  SetMAPDSRC_ComputedLane_offsetXaxisParams(packetHandle, value.offsetXaxis, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offsetYaxis");
  SetMAPDSRC_ComputedLane_offsetYaxisParams(packetHandle, value.offsetYaxis, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "rotateXY");
  if(value.rotateXY.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.rotateXY.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "scaleXaxis");
  if(value.scaleXaxis.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.scaleXaxis.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "scaleYaxis");
  if(value.scaleYaxis.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.scaleYaxis.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetMAPDSRC_ComputedLane_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPDSRC_NodeListXYParams(LONG packetHandle, struct MAPDSRC_NodeListXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "MAP", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nodes");
      GetMAPDSRC_NodeSetXYParams(packetHandle, value.nodes, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "computed");
      GetMAPDSRC_ComputedLaneParams(packetHandle, value.computed, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAPDSRC_NodeListXYParams(LONG packetHandle, struct MAPDSRC_NodeListXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nodes");
      SetMAPDSRC_NodeSetXYParams(packetHandle, value.nodes, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "computed");
      SetMAPDSRC_ComputedLaneParams(packetHandle, value.computed, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAPDSRC_ConnectingLaneParams(LONG packetHandle, struct MAPDSRC_ConnectingLane value, char oldPath[])
{
  char newPath[300]; 
  int j; 
  int k;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lane");
  value.lane = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuver");
  value.maneuver.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.maneuver.isValidFlag==1)
  {
    value.maneuver.isValidFlag = 1;
    value.maneuver.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
    if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
    {
      if(value.maneuver.stringLength > 0)
      {
        for(j=0; j<value.maneuver.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
          {
            value.maneuver.string[j] = '0';
          }
          else if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 1)
          {
            value.maneuver.string[j] = '1';
          }

          if(value.maneuver.stringLength == 1)
          {
            value.maneuver.string[1] = '0';
          }
          result = CheckLastError("MAP", gkFuncRefGet, result);
        }
      }
      else
      {
        for(k = value.maneuver.stringLength+1; k > -1; k--)
        {
          if(value.maneuver.string[k] == '1')
          {
            value.maneuver.string[k] = '0';
          }
        }
      }
    }

  }
  return result;
}

int SetMAPDSRC_ConnectingLaneParams(LONG packetHandle, struct MAPDSRC_ConnectingLane value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lane");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.lane);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuver");
  if(value.maneuver.isValidFlag==1)
  {
      for(j=0; j<value.maneuver.stringLength; j++)
      {
        if(value.maneuver.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPDSRC_ConnectionParams(LONG packetHandle, struct MAPDSRC_Connection value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectingLane");
  GetMAPDSRC_ConnectingLaneParams(packetHandle, value.connectingLane, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "remoteIntersection");
  value.remoteIntersection.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.remoteIntersection.isValidFlag==1)
  {
    GetMAPDSRC_IntersectionReferenceIDParams(packetHandle, value.remoteIntersection, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalGroup");
  value.signalGroup.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.signalGroup.isValidFlag==1)
  {
    value.signalGroup.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "userClass");
  value.userClass.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.userClass.isValidFlag==1)
  {
    value.userClass.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectionID");
  value.connectionID.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.connectionID.isValidFlag==1)
  {
    value.connectionID.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPDSRC_ConnectionParams(LONG packetHandle, struct MAPDSRC_Connection value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectingLane");
  SetMAPDSRC_ConnectingLaneParams(packetHandle, value.connectingLane, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "remoteIntersection");
  if(value.remoteIntersection.isValidFlag==1)
  {
    SetMAPDSRC_IntersectionReferenceIDParams(packetHandle, value.remoteIntersection, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalGroup");
  if(value.signalGroup.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.signalGroup.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "userClass");
  if(value.userClass.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.userClass.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectionID");
  if(value.connectionID.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.connectionID.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPDSRC_ConnectsToListParams(LONG packetHandle, struct MAPDSRC_ConnectsToList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPDSRC_ConnectionParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPDSRC_ConnectsToListParams(LONG packetHandle, struct MAPDSRC_ConnectsToList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPDSRC_ConnectionParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPDSRC_OverlayLaneListParams(LONG packetHandle, struct MAPDSRC_OverlayLaneList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      value.arrayValue[i] = C2xGetTokenInt64(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPDSRC_OverlayLaneListParams(LONG packetHandle, struct MAPDSRC_OverlayLaneList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    C2xSetTokenInt64(packetHandle, "MAP", newPath, value.arrayValue[i]);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPAddGrpC_ConnectionTrajectory_addGrpCParams(LONG packetHandle, struct MAPAddGrpC_ConnectionTrajectory_addGrpC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nodes");
  GetMAPDSRC_NodeSetXYParams(packetHandle, value.nodes, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPAddGrpC_ConnectionTrajectory_addGrpCParams(LONG packetHandle, struct MAPAddGrpC_ConnectionTrajectory_addGrpC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nodes");
  SetMAPDSRC_NodeSetXYParams(packetHandle, value.nodes, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPReg_GenericLaneParams(LONG packetHandle, WORD tableKey, struct MAPReg_GenericLane value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpC");
      GetMAPAddGrpC_ConnectionTrajectory_addGrpCParams(packetHandle, value.addGrpC, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAPReg_GenericLaneParams(LONG packetHandle, WORD tableKey, struct MAPReg_GenericLane value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpC");
      SetMAPAddGrpC_ConnectionTrajectory_addGrpCParams(packetHandle, value.addGrpC, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAPDSRC_RegionalExtensionGenericLaneParams(LONG packetHandle, struct MAPDSRC_RegionalExtensionGenericLane value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  GetMAPReg_GenericLaneParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPDSRC_RegionalExtensionGenericLaneParams(LONG packetHandle, struct MAPDSRC_RegionalExtensionGenericLane value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  SetMAPReg_GenericLaneParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPDSRC_GenericLane_regionalParams(LONG packetHandle, struct MAPDSRC_GenericLane_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPDSRC_RegionalExtensionGenericLaneParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPDSRC_GenericLane_regionalParams(LONG packetHandle, struct MAPDSRC_GenericLane_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPDSRC_RegionalExtensionGenericLaneParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPDSRC_GenericLaneParams(LONG packetHandle, struct MAPDSRC_GenericLane value, char oldPath[])
{
  char newPath[300]; 
  int j; 
  int k;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneID");
  value.laneID = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  value.name.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.name.isValidFlag==1)
  {
    value.name.stringLength = C2xGetTokenData(packetHandle, "MAP", newPath, elcount(value.name.string), value.name.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "ingressApproach");
  value.ingressApproach.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.ingressApproach.isValidFlag==1)
  {
    value.ingressApproach.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "egressApproach");
  value.egressApproach.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.egressApproach.isValidFlag==1)
  {
    value.egressApproach.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneAttributes");
  GetMAPDSRC_LaneAttributesParams(packetHandle, value.laneAttributes, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuvers");
  value.maneuvers.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.maneuvers.isValidFlag==1)
  {
    value.maneuvers.isValidFlag = 1;
    value.maneuvers.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
    if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
    {
      if(value.maneuvers.stringLength > 0)
      {
        for(j=0; j<value.maneuvers.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
          {
            value.maneuvers.string[j] = '0';
          }
          else if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 1)
          {
            value.maneuvers.string[j] = '1';
          }

          if(value.maneuvers.stringLength == 1)
          {
            value.maneuvers.string[1] = '0';
          }
          result = CheckLastError("MAP", gkFuncRefGet, result);
        }
      }
      else
      {
        for(k = value.maneuvers.stringLength+1; k > -1; k--)
        {
          if(value.maneuvers.string[k] == '1')
          {
            value.maneuvers.string[k] = '0';
          }
        }
      }
    }

  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nodeList");
  GetMAPDSRC_NodeListXYParams(packetHandle, value.nodeList, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectsTo");
  value.connectsTo.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.connectsTo.isValidFlag==1)
  {
    GetMAPDSRC_ConnectsToListParams(packetHandle, value.connectsTo, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "overlays");
  value.overlays.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.overlays.isValidFlag==1)
  {
    GetMAPDSRC_OverlayLaneListParams(packetHandle, value.overlays, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetMAPDSRC_GenericLane_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPDSRC_GenericLaneParams(LONG packetHandle, struct MAPDSRC_GenericLane value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneID");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.laneID);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  if(value.name.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "MAP", newPath, value.name.stringLength, value.name.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "ingressApproach");
  if(value.ingressApproach.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.ingressApproach.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "egressApproach");
  if(value.egressApproach.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.egressApproach.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneAttributes");
  SetMAPDSRC_LaneAttributesParams(packetHandle, value.laneAttributes, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuvers");
  if(value.maneuvers.isValidFlag==1)
  {
      for(j=0; j<value.maneuvers.stringLength; j++)
      {
        if(value.maneuvers.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nodeList");
  SetMAPDSRC_NodeListXYParams(packetHandle, value.nodeList, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectsTo");
  if(value.connectsTo.isValidFlag==1)
  {
    SetMAPDSRC_ConnectsToListParams(packetHandle, value.connectsTo, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "overlays");
  if(value.overlays.isValidFlag==1)
  {
    SetMAPDSRC_OverlayLaneListParams(packetHandle, value.overlays, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetMAPDSRC_GenericLane_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPDSRC_LaneListParams(LONG packetHandle, struct MAPDSRC_LaneList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPDSRC_GenericLaneParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPDSRC_LaneListParams(LONG packetHandle, struct MAPDSRC_LaneList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPDSRC_GenericLaneParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPDSRC_SignalControlZoneParams(LONG packetHandle, struct MAPDSRC_SignalControlZone value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "zone");
  GetMAPDSRC_RegionalExtensionEmptyParams(packetHandle, value.zone, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPDSRC_SignalControlZoneParams(LONG packetHandle, struct MAPDSRC_SignalControlZone value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "zone");
  SetMAPDSRC_RegionalExtensionEmptyParams(packetHandle, value.zone, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPDSRC_PreemptPriorityListParams(LONG packetHandle, struct MAPDSRC_PreemptPriorityList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPDSRC_SignalControlZoneParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPDSRC_PreemptPriorityListParams(LONG packetHandle, struct MAPDSRC_PreemptPriorityList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPDSRC_SignalControlZoneParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPDSRC_IntersectionGeometry_regionalParams(LONG packetHandle, struct MAPDSRC_IntersectionGeometry_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPDSRC_RegionalExtensionEmptyParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPDSRC_IntersectionGeometry_regionalParams(LONG packetHandle, struct MAPDSRC_IntersectionGeometry_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPDSRC_RegionalExtensionEmptyParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPDSRC_IntersectionGeometryParams(LONG packetHandle, struct MAPDSRC_IntersectionGeometry value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  value.name.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.name.isValidFlag==1)
  {
    value.name.stringLength = C2xGetTokenData(packetHandle, "MAP", newPath, elcount(value.name.string), value.name.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  GetMAPDSRC_IntersectionReferenceIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "revision");
  value.revision = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "refPoint");
  GetMAPDSRC_Position3DParams(packetHandle, value.refPoint, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneWidth");
  value.laneWidth.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.laneWidth.isValidFlag==1)
  {
    value.laneWidth.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimits");
  value.speedLimits.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.speedLimits.isValidFlag==1)
  {
    GetMAPDSRC_SpeedLimitListParams(packetHandle, value.speedLimits, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneSet");
  GetMAPDSRC_LaneListParams(packetHandle, value.laneSet, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "preemptPriorityData");
  value.preemptPriorityData.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.preemptPriorityData.isValidFlag==1)
  {
    GetMAPDSRC_PreemptPriorityListParams(packetHandle, value.preemptPriorityData, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetMAPDSRC_IntersectionGeometry_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPDSRC_IntersectionGeometryParams(LONG packetHandle, struct MAPDSRC_IntersectionGeometry value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  if(value.name.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "MAP", newPath, value.name.stringLength, value.name.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  SetMAPDSRC_IntersectionReferenceIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "revision");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.revision);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "refPoint");
  SetMAPDSRC_Position3DParams(packetHandle, value.refPoint, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneWidth");
  if(value.laneWidth.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.laneWidth.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimits");
  if(value.speedLimits.isValidFlag==1)
  {
    SetMAPDSRC_SpeedLimitListParams(packetHandle, value.speedLimits, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneSet");
  SetMAPDSRC_LaneListParams(packetHandle, value.laneSet, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "preemptPriorityData");
  if(value.preemptPriorityData.isValidFlag==1)
  {
    SetMAPDSRC_PreemptPriorityListParams(packetHandle, value.preemptPriorityData, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetMAPDSRC_IntersectionGeometry_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPDSRC_IntersectionGeometryListParams(LONG packetHandle, struct MAPDSRC_IntersectionGeometryList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPDSRC_IntersectionGeometryParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPDSRC_IntersectionGeometryListParams(LONG packetHandle, struct MAPDSRC_IntersectionGeometryList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPDSRC_IntersectionGeometryParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPDSRC_RoadSegmentReferenceIDParams(LONG packetHandle, struct MAPDSRC_RoadSegmentReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  value.region.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.region.isValidFlag==1)
  {
    value.region.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  value.id = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPDSRC_RoadSegmentReferenceIDParams(LONG packetHandle, struct MAPDSRC_RoadSegmentReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  if(value.region.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.region.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.id);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPDSRC_RoadLaneSetListParams(LONG packetHandle, struct MAPDSRC_RoadLaneSetList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPDSRC_GenericLaneParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPDSRC_RoadLaneSetListParams(LONG packetHandle, struct MAPDSRC_RoadLaneSetList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPDSRC_GenericLaneParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPDSRC_RoadSegment_regionalParams(LONG packetHandle, struct MAPDSRC_RoadSegment_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPDSRC_RegionalExtensionEmptyParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPDSRC_RoadSegment_regionalParams(LONG packetHandle, struct MAPDSRC_RoadSegment_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPDSRC_RegionalExtensionEmptyParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPDSRC_RoadSegmentParams(LONG packetHandle, struct MAPDSRC_RoadSegment value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  value.name.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.name.isValidFlag==1)
  {
    value.name.stringLength = C2xGetTokenData(packetHandle, "MAP", newPath, elcount(value.name.string), value.name.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  GetMAPDSRC_RoadSegmentReferenceIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "revision");
  value.revision = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "refPoint");
  GetMAPDSRC_Position3DParams(packetHandle, value.refPoint, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneWidth");
  value.laneWidth.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.laneWidth.isValidFlag==1)
  {
    value.laneWidth.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimits");
  value.speedLimits.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.speedLimits.isValidFlag==1)
  {
    GetMAPDSRC_SpeedLimitListParams(packetHandle, value.speedLimits, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "roadLaneSet");
  GetMAPDSRC_RoadLaneSetListParams(packetHandle, value.roadLaneSet, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetMAPDSRC_RoadSegment_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPDSRC_RoadSegmentParams(LONG packetHandle, struct MAPDSRC_RoadSegment value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  if(value.name.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "MAP", newPath, value.name.stringLength, value.name.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  SetMAPDSRC_RoadSegmentReferenceIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "revision");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.revision);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "refPoint");
  SetMAPDSRC_Position3DParams(packetHandle, value.refPoint, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneWidth");
  if(value.laneWidth.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.laneWidth.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimits");
  if(value.speedLimits.isValidFlag==1)
  {
    SetMAPDSRC_SpeedLimitListParams(packetHandle, value.speedLimits, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "roadLaneSet");
  SetMAPDSRC_RoadLaneSetListParams(packetHandle, value.roadLaneSet, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetMAPDSRC_RoadSegment_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPDSRC_RoadSegmentListParams(LONG packetHandle, struct MAPDSRC_RoadSegmentList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPDSRC_RoadSegmentParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPDSRC_RoadSegmentListParams(LONG packetHandle, struct MAPDSRC_RoadSegmentList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPDSRC_RoadSegmentParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPDSRC_DataParametersParams(LONG packetHandle, struct MAPDSRC_DataParameters value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "processMethod");
  value.processMethod.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.processMethod.isValidFlag==1)
  {
    value.processMethod.stringLength = C2xGetTokenData(packetHandle, "MAP", newPath, elcount(value.processMethod.string), value.processMethod.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "processAgency");
  value.processAgency.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.processAgency.isValidFlag==1)
  {
    value.processAgency.stringLength = C2xGetTokenData(packetHandle, "MAP", newPath, elcount(value.processAgency.string), value.processAgency.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lastCheckedDate");
  value.lastCheckedDate.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.lastCheckedDate.isValidFlag==1)
  {
    value.lastCheckedDate.stringLength = C2xGetTokenData(packetHandle, "MAP", newPath, elcount(value.lastCheckedDate.string), value.lastCheckedDate.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "geoidUsed");
  value.geoidUsed.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.geoidUsed.isValidFlag==1)
  {
    value.geoidUsed.stringLength = C2xGetTokenData(packetHandle, "MAP", newPath, elcount(value.geoidUsed.string), value.geoidUsed.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPDSRC_DataParametersParams(LONG packetHandle, struct MAPDSRC_DataParameters value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "processMethod");
  if(value.processMethod.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "MAP", newPath, value.processMethod.stringLength, value.processMethod.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "processAgency");
  if(value.processAgency.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "MAP", newPath, value.processAgency.stringLength, value.processAgency.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lastCheckedDate");
  if(value.lastCheckedDate.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "MAP", newPath, value.lastCheckedDate.stringLength, value.lastCheckedDate.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "geoidUsed");
  if(value.geoidUsed.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "MAP", newPath, value.geoidUsed.stringLength, value.geoidUsed.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPAddGrpC_RestrictionUserType_addGrpCParams(LONG packetHandle, struct MAPAddGrpC_RestrictionUserType_addGrpC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "emission");
  value.emission.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.emission.isValidFlag==1)
  {
    value.emission.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPAddGrpC_RestrictionUserType_addGrpCParams(LONG packetHandle, struct MAPAddGrpC_RestrictionUserType_addGrpC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "emission");
  if(value.emission.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.emission.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPReg_RestrictionUserTypeParams(LONG packetHandle, WORD tableKey, struct MAPReg_RestrictionUserType value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpC");
      GetMAPAddGrpC_RestrictionUserType_addGrpCParams(packetHandle, value.addGrpC, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAPReg_RestrictionUserTypeParams(LONG packetHandle, WORD tableKey, struct MAPReg_RestrictionUserType value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpC");
      SetMAPAddGrpC_RestrictionUserType_addGrpCParams(packetHandle, value.addGrpC, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAPDSRC_RegionalExtensionRestrictionUserTypeParams(LONG packetHandle, struct MAPDSRC_RegionalExtensionRestrictionUserType value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  GetMAPReg_RestrictionUserTypeParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPDSRC_RegionalExtensionRestrictionUserTypeParams(LONG packetHandle, struct MAPDSRC_RegionalExtensionRestrictionUserType value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  SetMAPReg_RestrictionUserTypeParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPDSRC_RestrictionUserType_regionalParams(LONG packetHandle, struct MAPDSRC_RestrictionUserType_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPDSRC_RegionalExtensionRestrictionUserTypeParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPDSRC_RestrictionUserType_regionalParams(LONG packetHandle, struct MAPDSRC_RestrictionUserType_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPDSRC_RegionalExtensionRestrictionUserTypeParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPDSRC_RestrictionUserTypeParams(LONG packetHandle, struct MAPDSRC_RestrictionUserType value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "MAP", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "basicType");
      value.basicType = C2xGetTokenInt(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
      GetMAPDSRC_RestrictionUserType_regionalParams(packetHandle, value.regional, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAPDSRC_RestrictionUserTypeParams(LONG packetHandle, struct MAPDSRC_RestrictionUserType value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "basicType");
      C2xSetTokenInt(packetHandle, "MAP", newPath, value.basicType);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
      SetMAPDSRC_RestrictionUserType_regionalParams(packetHandle, value.regional, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAPDSRC_RestrictionUserTypeListParams(LONG packetHandle, struct MAPDSRC_RestrictionUserTypeList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPDSRC_RestrictionUserTypeParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPDSRC_RestrictionUserTypeListParams(LONG packetHandle, struct MAPDSRC_RestrictionUserTypeList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPDSRC_RestrictionUserTypeParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPDSRC_RestrictionClassAssignmentParams(LONG packetHandle, struct MAPDSRC_RestrictionClassAssignment value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  value.id = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "users");
  GetMAPDSRC_RestrictionUserTypeListParams(packetHandle, value.users, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPDSRC_RestrictionClassAssignmentParams(LONG packetHandle, struct MAPDSRC_RestrictionClassAssignment value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.id);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "users");
  SetMAPDSRC_RestrictionUserTypeListParams(packetHandle, value.users, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPDSRC_RestrictionClassListParams(LONG packetHandle, struct MAPDSRC_RestrictionClassList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPDSRC_RestrictionClassAssignmentParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPDSRC_RestrictionClassListParams(LONG packetHandle, struct MAPDSRC_RestrictionClassList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPDSRC_RestrictionClassAssignmentParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPDSRC_MapDataParams(LONG packetHandle, struct MAPDSRC_MapData value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeStamp");
  value.timeStamp.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.timeStamp.isValidFlag==1)
  {
    value.timeStamp.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgIssueRevision");
  value.msgIssueRevision = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "layerType");
  value.layerType.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.layerType.isValidFlag==1)
  {
    value.layerType.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "layerID");
  value.layerID.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.layerID.isValidFlag==1)
  {
    value.layerID.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "intersections");
  value.intersections.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.intersections.isValidFlag==1)
  {
    GetMAPDSRC_IntersectionGeometryListParams(packetHandle, value.intersections, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "roadSegments");
  value.roadSegments.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.roadSegments.isValidFlag==1)
  {
    GetMAPDSRC_RoadSegmentListParams(packetHandle, value.roadSegments, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "dataParameters");
  value.dataParameters.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.dataParameters.isValidFlag==1)
  {
    GetMAPDSRC_DataParametersParams(packetHandle, value.dataParameters, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "restrictionList");
  value.restrictionList.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.restrictionList.isValidFlag==1)
  {
    GetMAPDSRC_RestrictionClassListParams(packetHandle, value.restrictionList, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPDSRC_MapDataParams(LONG packetHandle, struct MAPDSRC_MapData value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeStamp");
  if(value.timeStamp.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.timeStamp.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgIssueRevision");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.msgIssueRevision);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "layerType");
  if(value.layerType.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.layerType.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "layerID");
  if(value.layerID.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.layerID.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "intersections");
  if(value.intersections.isValidFlag==1)
  {
    SetMAPDSRC_IntersectionGeometryListParams(packetHandle, value.intersections, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "roadSegments");
  if(value.roadSegments.isValidFlag==1)
  {
    SetMAPDSRC_RoadSegmentListParams(packetHandle, value.roadSegments, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "dataParameters");
  if(value.dataParameters.isValidFlag==1)
  {
    SetMAPDSRC_DataParametersParams(packetHandle, value.dataParameters, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "restrictionList");
  if(value.restrictionList.isValidFlag==1)
  {
    SetMAPDSRC_RestrictionClassListParams(packetHandle, value.restrictionList, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int API_GetMAPParams(LONG packetHandle, struct MAP value)
{
  int result;
  result = 0;

  value.header.isValidFlag = 1;
  GetMAPITS_Container_ItsPduHeaderParams(packetHandle, value.header, "header");
  result = CheckLastError("MAP", gkFuncRefGet, result);

  value.map.isValidFlag = 1;
  GetMAPDSRC_MapDataParams(packetHandle, value.map, "map");
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int API_SetMAPParams(LONG packetHandle, struct MAP value)
{
  int result;
  result = 0;

  SetMAPITS_Container_ItsPduHeaderParams(packetHandle, value.header, "header");
  result = CheckLastError("MAP", gkFuncRefGet, result);

  SetMAPDSRC_MapDataParams(packetHandle, value.map, "map");
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

