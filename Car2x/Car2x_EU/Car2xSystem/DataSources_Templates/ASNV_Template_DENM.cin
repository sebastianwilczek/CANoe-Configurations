/*@!Encoding:1252*/
/*
//  (c) Vector Informatik GmbH. All rights reserved.
//
//  This file contains definitions of structs and methods that may be used
//  to set and get the values of an ASN.1 defined packet's payload.
//
//  //This example demonstrates how to set a packet's payload:
//  LONG packetHandle;
//  struct DENM payload;
//  //you need to set the values of the variable "payload" yourself
//  packetHandle = API_InitDENMPacket();
//  if (packetHandle!=0) {
//    if (API_SetDENMParams(packetHandle, payload)==0) {
//      if (C2xCompletePacket(packetHandle)==0) {
//        C2xOutputPacket(packetHandle);
//      }
//    }
//  }
//                                                                             */
includes
{

}
variables
{
    struct DENMItsPduHeader {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE protocolVersion;  // INTEGER, 0..255;
        BYTE messageID;  // INTEGER, 0..255, denm(1), cam(2), poi(3), spat(4), map(5), ivi(6), ev_rsr(7), tistpgtransaction(8), srem(9), ssem(10), evcsn(11), saem(12), rtcmem(13);
        DWORD stationID;  // INTEGER, 0..4294967295;
    };
    
    struct DENMActionID {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        DWORD originatingStationID;  // INTEGER, 0..4294967295;
        WORD sequenceNumber;  // INTEGER, 0..65535;
    };
    
    struct DENMPosConfidenceEllipse {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        WORD semiMajorConfidence;  // INTEGER, 0..4095, outOfRange(4094), unavailable(4095);
        WORD semiMinorConfidence;  // INTEGER, 0..4095, outOfRange(4094), unavailable(4095);
        WORD semiMajorOrientation;  // INTEGER, 0..3601, unavailable(3601);
    };
    
    struct DENMAltitude {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG altitudeValue;  // INTEGER, -100000..800001, unavailable(800001);
        INT altitudeConfidence;  // ENUMERATED, alt_000_01(0), alt_000_02(1), alt_000_05(2), alt_000_10(3), alt_000_20(4), alt_000_50(5), alt_001_00(6), alt_002_00(7), alt_005_00(8), alt_010_00(9), alt_020_00(10), alt_050_00(11), alt_100_00(12), alt_200_00(13), outOfRange(14), unavailable(15);
    };
    
    struct DENMReferencePosition {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG latitude;  // INTEGER, -900000000..900000001, unavailable(900000001);
        LONG longitude;  // INTEGER, -1800000000..1800000001, unavailable(1800000001);
        struct DENMPosConfidenceEllipse positionConfidenceEllipse;  // SEQUENCE;
        struct DENMAltitude altitude;  // SEQUENCE;
    };
    
    struct DENMManagementContainer {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct DENMActionID actionID;  // SEQUENCE;
        QWORD detectionTime;  // INTEGER, 0..4398046511103;
        QWORD referenceTime;  // INTEGER, 0..4398046511103;
        struct OPT_ENUM_ASN termination;  // ENUMERATED, OPTIONAL, isCancellation(0), isNegation(1);
        struct DENMReferencePosition eventPosition;  // SEQUENCE;
        struct OPT_ENUM_ASN relevanceDistance;  // ENUMERATED, OPTIONAL, lessThan50m(0), lessThan100m(1), lessThan200m(2), lessThan500m(3), lessThan1000m(4), lessThan5km(5), lessThan10km(6), over10km(7);
        struct OPT_ENUM_ASN relevanceTrafficDirection;  // ENUMERATED, OPTIONAL, allTrafficDirections(0), upstreamTraffic(1), downstreamTraffic(2), oppositeTraffic(3);
        struct OPT_DWORD_ASN validityDuration;  // INTEGER, OPTIONAL, 0..86400, timeOfDetection(0), oneSecondAfterDetection(1);
        struct OPT_WORD_ASN transmissionInterval;  // INTEGER, OPTIONAL, 1..10000, oneMilliSecond(1), tenSeconds(10000);
        BYTE stationType;  // INTEGER, 0..255, unknown(0), pedestrian(1), cyclist(2), moped(3), motorcycle(4), passengerCar(5), bus(6), lightTruck(7), heavyTruck(8), trailer(9), specialVehicles(10), tram(11), roadSideUnit(15);
    };
    
    struct DENMCauseCode {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE causeCode;  // INTEGER, 0..255, reserved(0), trafficCondition(1), accident(2), roadworks(3), impassability(5), adverseWeatherCondition_Adhesion(6), aquaplannning(7), hazardousLocation_SurfaceCondition(9), hazardousLocation_ObstacleOnTheRoad(10), hazardousLocation_AnimalOnTheRoad(11), humanPresenceOnTheRoad(12), wrongWayDriving(14), rescueAndRecoveryWorkInProgress(15), adverseWeatherCondition_ExtremeWeatherCondition(17), adverseWeatherCondition_Visibility(18), adverseWeatherCondition_Precipitation(19), slowVehicle(26), dangerousEndOfQueue(27), vehicleBreakdown(91), postCrash(92), humanProblem(93), stationaryVehicle(94), emergencyVehicleApproaching(95), hazardousLocation_DangerousCurve(96), collisionRisk(97), signalViolation(98), dangerousSituation(99);
        BYTE subCauseCode;  // INTEGER, 0..255;
    };
    
    struct DENMDeltaReferencePosition {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG deltaLatitude;  // INTEGER, -131071..131072, unavailable(131072);
        LONG deltaLongitude;  // INTEGER, -131071..131072, unavailable(131072);
        INT deltaAltitude;  // INTEGER, -12700..12800, unavailable(12800);
    };
    
    struct DENMEventPoint {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct DENMDeltaReferencePosition eventPosition;  // SEQUENCE;
        struct OPT_WORD_ASN eventDeltaTime;  // INTEGER, OPTIONAL, 1..65535;
        BYTE informationQuality;  // INTEGER, 0..7, unavailable(0), lowest(1), highest(7);
    };
    
    struct DENMEventHistory {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct DENMEventPoint arrayValue[23];  // SEQUENCE;
    };
    
    struct DENMSituationContainer {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE informationQuality;  // INTEGER, 0..7, unavailable(0), lowest(1), highest(7);
        struct DENMCauseCode eventType;  // SEQUENCE;
        struct DENMCauseCode linkedCause;  // SEQUENCE, OPTIONAL;
        struct DENMEventHistory eventHistory;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct DENMSpeed {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        WORD speedValue;  // INTEGER, 0..16383, unavailable(16383);
        BYTE speedConfidence;  // INTEGER, 1..127, outOfRange(126), unavailable(127);
    };
    
    struct DENMHeading {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        WORD headingValue;  // INTEGER, 0..3601, unavailable(3601);
        BYTE headingConfidence;  // INTEGER, 1..127, outOfRange(126), unavailable(127);
    };
    
    struct DENMPathPoint {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct DENMDeltaReferencePosition pathPosition;  // SEQUENCE;
        struct OPT_WORD_ASN pathDeltaTime;  // INTEGER, OPTIONAL, 1..65535;
    };
    
    struct DENMPathHistory {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct DENMPathPoint arrayValue[40];  // SEQUENCE;
    };
    
    struct DENMTraces {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct DENMPathHistory arrayValue[7];  // SEQUENCEOF;
    };
    
    struct DENMLocationContainer {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct DENMSpeed eventSpeed;  // SEQUENCE, OPTIONAL;
        struct DENMHeading eventPositionHeading;  // SEQUENCE, OPTIONAL;
        struct DENMTraces traces;  // SEQUENCEOF;
        struct OPT_ENUM_ASN roadType;  // ENUMERATED, OPTIONAL, urban_NoStructuralSeparationToOppositeLanes(0), urban_WithStructuralSeparationToOppositeLanes(1), nonUrban_NoStructuralSeparationToOppositeLanes(2), nonUrban_WithStructuralSeparationToOppositeLanes(3);
    };
    
    struct DENMPositionOfPillars {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        BYTE arrayValue[3];  // INTEGER, 1..30, unavailable(30);
    };
    
    struct DENMPositionOfOccupants {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[21];
        INT  stringLength;
    };
    
    struct DENMImpactReductionContainer {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE heightLonCarrLeft;  // INTEGER, 1..100, unavailable(100);
        BYTE heightLonCarrRight;  // INTEGER, 1..100, unavailable(100);
        BYTE posLonCarrLeft;  // INTEGER, 1..127, unavailable(127);
        BYTE posLonCarrRight;  // INTEGER, 1..127, unavailable(127);
        struct DENMPositionOfPillars positionOfPillars;  // SEQUENCEOF;
        BYTE posCentMass;  // INTEGER, 1..63, unavailable(63);
        BYTE wheelBaseVehicle;  // INTEGER, 1..127, unavailable(127);
        BYTE turningRadius;  // INTEGER, 1..255, unavailable(255);
        BYTE posFrontAx;  // INTEGER, 1..20, unavailable(20);
        struct DENMPositionOfOccupants positionOfOccupants;  // BITSTRING;
        WORD vehicleMass;  // INTEGER, 1..1024, unavailable(1024);
        INT requestResponseIndication;  // ENUMERATED, request(0), response(1);
    };
    
    struct DENMLightBarSirenInUse {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[3];
        INT  stringLength;
    };
    
    struct DENMDrivingLaneStatus {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[14];
        INT  stringLength;
    };
    
    struct DENMClosedLanes {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_ENUM_ASN innerhardShoulderStatus;  // ENUMERATED, OPTIONAL, availableForStopping(0), closed(1), availableForDriving(2);
        struct OPT_ENUM_ASN outerhardShoulderStatus;  // ENUMERATED, OPTIONAL, availableForStopping(0), closed(1), availableForDriving(2);
        struct DENMDrivingLaneStatus drivingLaneStatus;  // BITSTRING, OPTIONAL;
    };
    
    struct DENMRestrictedTypes {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        BYTE arrayValue[3];  // INTEGER, 0..255, unknown(0), pedestrian(1), cyclist(2), moped(3), motorcycle(4), passengerCar(5), bus(6), lightTruck(7), heavyTruck(8), trailer(9), specialVehicles(10), tram(11), roadSideUnit(15);
    };
    
    struct DENMItineraryPath {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct DENMReferencePosition arrayValue[40];  // SEQUENCE;
    };
    
    struct DENMReferenceDenms {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct DENMActionID arrayValue[8];  // SEQUENCE;
    };
    
    struct DENMRoadWorksContainerExtended {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct DENMLightBarSirenInUse lightBarSirenInUse;  // BITSTRING, OPTIONAL;
        struct DENMClosedLanes closedLanes;  // SEQUENCE, OPTIONAL;
        struct DENMRestrictedTypes restriction;  // SEQUENCEOF, OPTIONAL;
        struct OPT_BYTE_ASN speedLimit;  // INTEGER, OPTIONAL, 1..255;
        struct DENMCauseCode incidentIndication;  // SEQUENCE, OPTIONAL;
        struct DENMItineraryPath recommendedPath;  // SEQUENCEOF, OPTIONAL;
        struct DENMDeltaReferencePosition startingPointSpeedLimit;  // SEQUENCE, OPTIONAL;
        struct OPT_ENUM_ASN trafficFlowRule;  // ENUMERATED, OPTIONAL, noPassing(0), noPassingForTrucks(1), passToRight(2), passToLeft(3);
        struct DENMReferenceDenms referenceDenms;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct DENM_DangerousGoodsExtended_emergencyActionCode {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[25];
        INT  stringLength;
    };
    
    struct DENM_DangerousGoodsExtended_phoneNumber {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct DENM_DangerousGoodsExtended_companyName {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[25];
        INT  stringLength;
    };
    
    struct DENMDangerousGoodsExtended {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT dangerousGoodsType;  // ENUMERATED, explosives1(0), explosives2(1), explosives3(2), explosives4(3), explosives5(4), explosives6(5), flammableGases(6), nonFlammableGases(7), toxicGases(8), flammableLiquids(9), flammableSolids(10), substancesLiableToSpontaneousCombustion(11), substancesEmittingFlammableGasesUponContactWithWater(12), oxidizingSubstances(13), organicPeroxides(14), toxicSubstances(15), infectiousSubstances(16), radioactiveMaterial(17), corrosiveSubstances(18), miscellaneousDangerousSubstances(19);
        WORD unNumber;  // INTEGER, 0..9999;
        INT elevatedTemperature;  // BOOLEAN;
        INT tunnelsRestricted;  // BOOLEAN;
        INT limitedQuantity;  // BOOLEAN;
        struct DENM_DangerousGoodsExtended_emergencyActionCode emergencyActionCode;  // IA5STRING, OPTIONAL;
        struct DENM_DangerousGoodsExtended_phoneNumber phoneNumber;  // NUMERICSTRING, OPTIONAL;
        struct DENM_DangerousGoodsExtended_companyName companyName;  // UTF8STRING, OPTIONAL;
    };
    
    struct DENMWMInumber {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[4];
        INT  stringLength;
    };
    
    struct DENMVDS {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[7];
        INT  stringLength;
    };
    
    struct DENMVehicleIdentification {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct DENMWMInumber wMInumber;  // IA5STRING, OPTIONAL;
        struct DENMVDS vDS;  // IA5STRING, OPTIONAL;
    };
    
    struct DENMEnergyStorageType {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[8];
        INT  stringLength;
    };
    
    struct DENMStationaryVehicleContainer {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_ENUM_ASN stationarySince;  // ENUMERATED, OPTIONAL, lessThan1Minute(0), lessThan2Minutes(1), lessThan15Minutes(2), equalOrGreater15Minutes(3);
        struct DENMCauseCode stationaryCause;  // SEQUENCE, OPTIONAL;
        struct DENMDangerousGoodsExtended carryingDangerousGoods;  // SEQUENCE, OPTIONAL;
        struct OPT_BYTE_ASN numberOfOccupants;  // INTEGER, OPTIONAL, 0..127, oneOccupant(1), unavailable(127);
        struct DENMVehicleIdentification vehicleIdentification;  // SEQUENCE, OPTIONAL;
        struct DENMEnergyStorageType energyStorageType;  // BITSTRING, OPTIONAL;
    };
    
    struct DENMAlacarteContainer {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_INT_ASN lanePosition;  // INTEGER, OPTIONAL, -1..14, offTheRoad(-1), hardShoulder(0), outermostDrivingLane(1), secondLaneFromOutside(2);
        struct DENMImpactReductionContainer impactReduction;  // SEQUENCE, OPTIONAL;
        struct OPT_INT_ASN externalTemperature;  // INTEGER, OPTIONAL, -60..67, equalOrSmallerThanMinus60Deg(-60), oneDegreeCelsius(1), equalOrGreaterThan67Deg(67);
        struct DENMRoadWorksContainerExtended roadWorks;  // SEQUENCE, OPTIONAL;
        struct OPT_ENUM_ASN positioningSolution;  // ENUMERATED, OPTIONAL, noPositioningSolution(0), sGNSS(1), dGNSS(2), sGNSSplusDR(3), dGNSSplusDR(4), dR(5);
        struct DENMStationaryVehicleContainer stationaryVehicle;  // SEQUENCE, OPTIONAL;
    };
    
    struct DENMDecentralizedEnvironmentalNotificationMessage {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct DENMManagementContainer management;  // SEQUENCE;
        struct DENMSituationContainer situation;  // SEQUENCE, OPTIONAL;
        struct DENMLocationContainer location;  // SEQUENCE, OPTIONAL;
        struct DENMAlacarteContainer alacarte;  // SEQUENCE, OPTIONAL;
    };
    
    struct DENM {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct DENMItsPduHeader header;  // SEQUENCE;
        struct DENMDecentralizedEnvironmentalNotificationMessage denm;  // SEQUENCE;
    };
    
}

/*
// init function to create a simple packet handle
*/ 
LONG API_InitDENMPacket()
{
  return C2xInitPacket("DENM"); 
}

/*
// init function to create a simple packet handle and
// initialize the struct with valid data
*/ 
LONG API_InitDENMPacket(struct DENM msgStruct)
{
  long pktHandle;

  pktHandle = API_InitDENMPacket();

  if (pktHandle != 0)
  {
    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      API_GetDENMParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}

/*
// init function to create a packet with security layer and
// initialize the struct with valid data
*/ 
LONG API_InitDENMPacket(struct DENM msgStruct, char packetTypeDesignator[], char certificateName[])
{
  long pktHandle, certHdl;

  // initialize the packet
  pktHandle = C2xInitPacket("DENM", packetTypeDesignator);

  if (pktHandle != 0)
  {
    certHdl = C2xSecCertificateGetHandle(certificateName);  // get the certificate handle for the cert with name "certificateName"
    if (certHdl != 0) 
    {
      C2xSecPacketSetSignerHandle(pktHandle, certHdl); // set the certHdl to the packet
    }

    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      // copy application data to the application structure
      API_GetDENMParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}
    

int GetDENMItsPduHeaderParams(LONG packetHandle, struct DENMItsPduHeader value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "protocolVersion");
  value.protocolVersion = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "messageID");
  value.messageID = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationID");
  value.stationID = C2xGetTokenInt64(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int SetDENMItsPduHeaderParams(LONG packetHandle, struct DENMItsPduHeader value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "protocolVersion");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.protocolVersion);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "messageID");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.messageID);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationID");
  C2xSetTokenInt64(packetHandle, "DENM", newPath, value.stationID);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int GetDENMActionIDParams(LONG packetHandle, struct DENMActionID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "originatingStationID");
  value.originatingStationID = C2xGetTokenInt64(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sequenceNumber");
  value.sequenceNumber = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int SetDENMActionIDParams(LONG packetHandle, struct DENMActionID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "originatingStationID");
  C2xSetTokenInt64(packetHandle, "DENM", newPath, value.originatingStationID);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sequenceNumber");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.sequenceNumber);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int GetDENMPosConfidenceEllipseParams(LONG packetHandle, struct DENMPosConfidenceEllipse value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "semiMajorConfidence");
  value.semiMajorConfidence = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "semiMinorConfidence");
  value.semiMinorConfidence = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "semiMajorOrientation");
  value.semiMajorOrientation = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int SetDENMPosConfidenceEllipseParams(LONG packetHandle, struct DENMPosConfidenceEllipse value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "semiMajorConfidence");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.semiMajorConfidence);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "semiMinorConfidence");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.semiMinorConfidence);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "semiMajorOrientation");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.semiMajorOrientation);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int GetDENMAltitudeParams(LONG packetHandle, struct DENMAltitude value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "altitudeValue");
  value.altitudeValue = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "altitudeConfidence");
  value.altitudeConfidence = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int SetDENMAltitudeParams(LONG packetHandle, struct DENMAltitude value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "altitudeValue");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.altitudeValue);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "altitudeConfidence");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.altitudeConfidence);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int GetDENMReferencePositionParams(LONG packetHandle, struct DENMReferencePosition value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latitude");
  value.latitude = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longitude");
  value.longitude = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "positionConfidenceEllipse");
  GetDENMPosConfidenceEllipseParams(packetHandle, value.positionConfidenceEllipse, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "altitude");
  GetDENMAltitudeParams(packetHandle, value.altitude, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int SetDENMReferencePositionParams(LONG packetHandle, struct DENMReferencePosition value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latitude");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.latitude);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longitude");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.longitude);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "positionConfidenceEllipse");
  SetDENMPosConfidenceEllipseParams(packetHandle, value.positionConfidenceEllipse, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "altitude");
  SetDENMAltitudeParams(packetHandle, value.altitude, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int GetDENMManagementContainerParams(LONG packetHandle, struct DENMManagementContainer value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "actionID");
  GetDENMActionIDParams(packetHandle, value.actionID, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "detectionTime");
  value.detectionTime = C2xGetTokenInt64(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "referenceTime");
  value.referenceTime = C2xGetTokenInt64(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "termination");
  value.termination.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.termination.isValidFlag==1)
  {
    value.termination.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventPosition");
  GetDENMReferencePositionParams(packetHandle, value.eventPosition, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "relevanceDistance");
  value.relevanceDistance.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.relevanceDistance.isValidFlag==1)
  {
    value.relevanceDistance.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "relevanceTrafficDirection");
  value.relevanceTrafficDirection.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.relevanceTrafficDirection.isValidFlag==1)
  {
    value.relevanceTrafficDirection.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "validityDuration");
  value.validityDuration.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.validityDuration.isValidFlag==1)
  {
    value.validityDuration.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "transmissionInterval");
  value.transmissionInterval.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.transmissionInterval.isValidFlag==1)
  {
    value.transmissionInterval.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationType");
  value.stationType = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int SetDENMManagementContainerParams(LONG packetHandle, struct DENMManagementContainer value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "actionID");
  SetDENMActionIDParams(packetHandle, value.actionID, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "detectionTime");
  C2xSetTokenInt64(packetHandle, "DENM", newPath, value.detectionTime);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "referenceTime");
  C2xSetTokenInt64(packetHandle, "DENM", newPath, value.referenceTime);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "termination");
  if(value.termination.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "DENM", newPath, value.termination.value);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventPosition");
  SetDENMReferencePositionParams(packetHandle, value.eventPosition, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "relevanceDistance");
  if(value.relevanceDistance.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "DENM", newPath, value.relevanceDistance.value);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "relevanceTrafficDirection");
  if(value.relevanceTrafficDirection.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "DENM", newPath, value.relevanceTrafficDirection.value);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "validityDuration");
  if(value.validityDuration.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "DENM", newPath, value.validityDuration.value);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "transmissionInterval");
  if(value.transmissionInterval.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "DENM", newPath, value.transmissionInterval.value);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationType");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.stationType);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int GetDENMCauseCodeParams(LONG packetHandle, struct DENMCauseCode value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "causeCode");
  value.causeCode = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "subCauseCode");
  value.subCauseCode = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int SetDENMCauseCodeParams(LONG packetHandle, struct DENMCauseCode value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "causeCode");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.causeCode);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "subCauseCode");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.subCauseCode);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int GetDENMDeltaReferencePositionParams(LONG packetHandle, struct DENMDeltaReferencePosition value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "deltaLatitude");
  value.deltaLatitude = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "deltaLongitude");
  value.deltaLongitude = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "deltaAltitude");
  value.deltaAltitude = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int SetDENMDeltaReferencePositionParams(LONG packetHandle, struct DENMDeltaReferencePosition value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "deltaLatitude");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.deltaLatitude);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "deltaLongitude");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.deltaLongitude);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "deltaAltitude");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.deltaAltitude);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int GetDENMEventPointParams(LONG packetHandle, struct DENMEventPoint value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventPosition");
  GetDENMDeltaReferencePositionParams(packetHandle, value.eventPosition, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventDeltaTime");
  value.eventDeltaTime.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.eventDeltaTime.isValidFlag==1)
  {
    value.eventDeltaTime.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "informationQuality");
  value.informationQuality = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int SetDENMEventPointParams(LONG packetHandle, struct DENMEventPoint value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventPosition");
  SetDENMDeltaReferencePositionParams(packetHandle, value.eventPosition, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventDeltaTime");
  if(value.eventDeltaTime.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "DENM", newPath, value.eventDeltaTime.value);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "informationQuality");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.informationQuality);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int GetDENMEventHistoryParams(LONG packetHandle, struct DENMEventHistory value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "DENM", oldPath);
  if((result = CheckLastError("DENM", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetDENMEventPointParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("DENM", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetDENMEventHistoryParams(LONG packetHandle, struct DENMEventHistory value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "DENM", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetDENMEventPointParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  return result;
}

int GetDENMSituationContainerParams(LONG packetHandle, struct DENMSituationContainer value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "informationQuality");
  value.informationQuality = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventType");
  GetDENMCauseCodeParams(packetHandle, value.eventType, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "linkedCause");
  value.linkedCause.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.linkedCause.isValidFlag==1)
  {
    GetDENMCauseCodeParams(packetHandle, value.linkedCause, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventHistory");
  value.eventHistory.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.eventHistory.isValidFlag==1)
  {
    GetDENMEventHistoryParams(packetHandle, value.eventHistory, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  return result;
}

int SetDENMSituationContainerParams(LONG packetHandle, struct DENMSituationContainer value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "informationQuality");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.informationQuality);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventType");
  SetDENMCauseCodeParams(packetHandle, value.eventType, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "linkedCause");
  if(value.linkedCause.isValidFlag==1)
  {
    SetDENMCauseCodeParams(packetHandle, value.linkedCause, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventHistory");
  if(value.eventHistory.isValidFlag==1)
  {
    SetDENMEventHistoryParams(packetHandle, value.eventHistory, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  return result;
}

int GetDENMSpeedParams(LONG packetHandle, struct DENMSpeed value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedValue");
  value.speedValue = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedConfidence");
  value.speedConfidence = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int SetDENMSpeedParams(LONG packetHandle, struct DENMSpeed value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedValue");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.speedValue);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedConfidence");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.speedConfidence);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int GetDENMHeadingParams(LONG packetHandle, struct DENMHeading value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "headingValue");
  value.headingValue = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "headingConfidence");
  value.headingConfidence = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int SetDENMHeadingParams(LONG packetHandle, struct DENMHeading value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "headingValue");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.headingValue);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "headingConfidence");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.headingConfidence);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int GetDENMPathPointParams(LONG packetHandle, struct DENMPathPoint value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathPosition");
  GetDENMDeltaReferencePositionParams(packetHandle, value.pathPosition, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathDeltaTime");
  value.pathDeltaTime.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.pathDeltaTime.isValidFlag==1)
  {
    value.pathDeltaTime.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  return result;
}

int SetDENMPathPointParams(LONG packetHandle, struct DENMPathPoint value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathPosition");
  SetDENMDeltaReferencePositionParams(packetHandle, value.pathPosition, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathDeltaTime");
  if(value.pathDeltaTime.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "DENM", newPath, value.pathDeltaTime.value);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  return result;
}

int GetDENMPathHistoryParams(LONG packetHandle, struct DENMPathHistory value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "DENM", oldPath);
  if((result = CheckLastError("DENM", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetDENMPathPointParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("DENM", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetDENMPathHistoryParams(LONG packetHandle, struct DENMPathHistory value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "DENM", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetDENMPathPointParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  return result;
}

int GetDENMTracesParams(LONG packetHandle, struct DENMTraces value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "DENM", oldPath);
  if((result = CheckLastError("DENM", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetDENMPathHistoryParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("DENM", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetDENMTracesParams(LONG packetHandle, struct DENMTraces value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "DENM", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetDENMPathHistoryParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  return result;
}

int GetDENMLocationContainerParams(LONG packetHandle, struct DENMLocationContainer value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventSpeed");
  value.eventSpeed.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.eventSpeed.isValidFlag==1)
  {
    GetDENMSpeedParams(packetHandle, value.eventSpeed, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventPositionHeading");
  value.eventPositionHeading.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.eventPositionHeading.isValidFlag==1)
  {
    GetDENMHeadingParams(packetHandle, value.eventPositionHeading, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "traces");
  GetDENMTracesParams(packetHandle, value.traces, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "roadType");
  value.roadType.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.roadType.isValidFlag==1)
  {
    value.roadType.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  return result;
}

int SetDENMLocationContainerParams(LONG packetHandle, struct DENMLocationContainer value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventSpeed");
  if(value.eventSpeed.isValidFlag==1)
  {
    SetDENMSpeedParams(packetHandle, value.eventSpeed, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventPositionHeading");
  if(value.eventPositionHeading.isValidFlag==1)
  {
    SetDENMHeadingParams(packetHandle, value.eventPositionHeading, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "traces");
  SetDENMTracesParams(packetHandle, value.traces, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "roadType");
  if(value.roadType.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "DENM", newPath, value.roadType.value);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  return result;
}

int GetDENMPositionOfPillarsParams(LONG packetHandle, struct DENMPositionOfPillars value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "DENM", oldPath);
  if((result = CheckLastError("DENM", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      value.arrayValue[i] = C2xGetTokenInt64(packetHandle, "DENM", newPath);
      result = CheckLastError("DENM", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetDENMPositionOfPillarsParams(LONG packetHandle, struct DENMPositionOfPillars value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "DENM", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    C2xSetTokenInt64(packetHandle, "DENM", newPath, value.arrayValue[i]);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  return result;
}

int GetDENMImpactReductionContainerParams(LONG packetHandle, struct DENMImpactReductionContainer value, char oldPath[])
{
  char newPath[300]; 
  int j; 
  int k;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heightLonCarrLeft");
  value.heightLonCarrLeft = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heightLonCarrRight");
  value.heightLonCarrRight = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posLonCarrLeft");
  value.posLonCarrLeft = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posLonCarrRight");
  value.posLonCarrRight = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "positionOfPillars");
  GetDENMPositionOfPillarsParams(packetHandle, value.positionOfPillars, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posCentMass");
  value.posCentMass = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "wheelBaseVehicle");
  value.wheelBaseVehicle = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "turningRadius");
  value.turningRadius = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posFrontAx");
  value.posFrontAx = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "positionOfOccupants");
  value.positionOfOccupants.isValidFlag = 1;
  value.positionOfOccupants.stringLength = C2xGetTokenLengthBit(packetHandle, "DENM", newPath);
  if ((result = CheckLastError("DENM", gkFuncRefGet, result))==0)
  {
    if(value.positionOfOccupants.stringLength > 0)
    {
      for(j=0; j<value.positionOfOccupants.stringLength; j++)
      {
        if(C2xGetTokenBitOfBitString(packetHandle, "DENM", newPath, j) == 0)
        {
          value.positionOfOccupants.string[j] = '0';
        }
        else if(C2xGetTokenBitOfBitString(packetHandle, "DENM", newPath, j) == 1)
        {
          value.positionOfOccupants.string[j] = '1';
        }

        if(value.positionOfOccupants.stringLength == 1)
        {
          value.positionOfOccupants.string[1] = '0';
        }
        result = CheckLastError("DENM", gkFuncRefGet, result);
      }
    }
    else
    {
      for(k = value.positionOfOccupants.stringLength+1; k > -1; k--)
      {
        if(value.positionOfOccupants.string[k] == '1')
        {
          value.positionOfOccupants.string[k] = '0';
        }
      }
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vehicleMass");
  value.vehicleMass = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "requestResponseIndication");
  value.requestResponseIndication = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int SetDENMImpactReductionContainerParams(LONG packetHandle, struct DENMImpactReductionContainer value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heightLonCarrLeft");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.heightLonCarrLeft);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heightLonCarrRight");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.heightLonCarrRight);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posLonCarrLeft");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.posLonCarrLeft);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posLonCarrRight");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.posLonCarrRight);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "positionOfPillars");
  SetDENMPositionOfPillarsParams(packetHandle, value.positionOfPillars, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posCentMass");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.posCentMass);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "wheelBaseVehicle");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.wheelBaseVehicle);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "turningRadius");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.turningRadius);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posFrontAx");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.posFrontAx);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "positionOfOccupants");
    for(j=0; j<value.positionOfOccupants.stringLength; j++)
    {
      if(value.positionOfOccupants.string[j] == '0')
      {
        C2xSetTokenBitOfBitString(packetHandle, "DENM", newPath, j, 0);
      }
      else
      {
        C2xSetTokenBitOfBitString(packetHandle, "DENM", newPath, j, 1);
      }
      result = CheckLastError("DENM", gkFuncRefGet, result);
    }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vehicleMass");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.vehicleMass);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "requestResponseIndication");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.requestResponseIndication);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int GetDENMClosedLanesParams(LONG packetHandle, struct DENMClosedLanes value, char oldPath[])
{
  char newPath[300]; 
  int j; 
  int k;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "innerhardShoulderStatus");
  value.innerhardShoulderStatus.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.innerhardShoulderStatus.isValidFlag==1)
  {
    value.innerhardShoulderStatus.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "outerhardShoulderStatus");
  value.outerhardShoulderStatus.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.outerhardShoulderStatus.isValidFlag==1)
  {
    value.outerhardShoulderStatus.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "drivingLaneStatus");
  value.drivingLaneStatus.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.drivingLaneStatus.isValidFlag==1)
  {
    value.drivingLaneStatus.isValidFlag = 1;
    value.drivingLaneStatus.stringLength = C2xGetTokenLengthBit(packetHandle, "DENM", newPath);
    if ((result = CheckLastError("DENM", gkFuncRefGet, result))==0)
    {
      if(value.drivingLaneStatus.stringLength > 0)
      {
        for(j=0; j<value.drivingLaneStatus.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "DENM", newPath, j) == 0)
          {
            value.drivingLaneStatus.string[j] = '0';
          }
          else if(C2xGetTokenBitOfBitString(packetHandle, "DENM", newPath, j) == 1)
          {
            value.drivingLaneStatus.string[j] = '1';
          }

          if(value.drivingLaneStatus.stringLength == 1)
          {
            value.drivingLaneStatus.string[1] = '0';
          }
          result = CheckLastError("DENM", gkFuncRefGet, result);
        }
      }
      else
      {
        for(k = value.drivingLaneStatus.stringLength+1; k > -1; k--)
        {
          if(value.drivingLaneStatus.string[k] == '1')
          {
            value.drivingLaneStatus.string[k] = '0';
          }
        }
      }
    }

  }
  return result;
}

int SetDENMClosedLanesParams(LONG packetHandle, struct DENMClosedLanes value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "innerhardShoulderStatus");
  if(value.innerhardShoulderStatus.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "DENM", newPath, value.innerhardShoulderStatus.value);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "outerhardShoulderStatus");
  if(value.outerhardShoulderStatus.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "DENM", newPath, value.outerhardShoulderStatus.value);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "drivingLaneStatus");
  if(value.drivingLaneStatus.isValidFlag==1)
  {
      for(j=0; j<value.drivingLaneStatus.stringLength; j++)
      {
        if(value.drivingLaneStatus.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "DENM", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "DENM", newPath, j, 1);
        }
        result = CheckLastError("DENM", gkFuncRefGet, result);
      }
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  return result;
}

int GetDENMRestrictedTypesParams(LONG packetHandle, struct DENMRestrictedTypes value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "DENM", oldPath);
  if((result = CheckLastError("DENM", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      value.arrayValue[i] = C2xGetTokenInt64(packetHandle, "DENM", newPath);
      result = CheckLastError("DENM", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetDENMRestrictedTypesParams(LONG packetHandle, struct DENMRestrictedTypes value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "DENM", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    C2xSetTokenInt64(packetHandle, "DENM", newPath, value.arrayValue[i]);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  return result;
}

int GetDENMItineraryPathParams(LONG packetHandle, struct DENMItineraryPath value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "DENM", oldPath);
  if((result = CheckLastError("DENM", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetDENMReferencePositionParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("DENM", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetDENMItineraryPathParams(LONG packetHandle, struct DENMItineraryPath value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "DENM", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetDENMReferencePositionParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  return result;
}

int GetDENMReferenceDenmsParams(LONG packetHandle, struct DENMReferenceDenms value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "DENM", oldPath);
  if((result = CheckLastError("DENM", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetDENMActionIDParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("DENM", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetDENMReferenceDenmsParams(LONG packetHandle, struct DENMReferenceDenms value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "DENM", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetDENMActionIDParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  return result;
}

int GetDENMRoadWorksContainerExtendedParams(LONG packetHandle, struct DENMRoadWorksContainerExtended value, char oldPath[])
{
  char newPath[300]; 
  int j; 
  int k;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lightBarSirenInUse");
  value.lightBarSirenInUse.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.lightBarSirenInUse.isValidFlag==1)
  {
    value.lightBarSirenInUse.isValidFlag = 1;
    value.lightBarSirenInUse.stringLength = C2xGetTokenLengthBit(packetHandle, "DENM", newPath);
    if ((result = CheckLastError("DENM", gkFuncRefGet, result))==0)
    {
      if(value.lightBarSirenInUse.stringLength > 0)
      {
        for(j=0; j<value.lightBarSirenInUse.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "DENM", newPath, j) == 0)
          {
            value.lightBarSirenInUse.string[j] = '0';
          }
          else if(C2xGetTokenBitOfBitString(packetHandle, "DENM", newPath, j) == 1)
          {
            value.lightBarSirenInUse.string[j] = '1';
          }

          if(value.lightBarSirenInUse.stringLength == 1)
          {
            value.lightBarSirenInUse.string[1] = '0';
          }
          result = CheckLastError("DENM", gkFuncRefGet, result);
        }
      }
      else
      {
        for(k = value.lightBarSirenInUse.stringLength+1; k > -1; k--)
        {
          if(value.lightBarSirenInUse.string[k] == '1')
          {
            value.lightBarSirenInUse.string[k] = '0';
          }
        }
      }
    }

  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "closedLanes");
  value.closedLanes.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.closedLanes.isValidFlag==1)
  {
    GetDENMClosedLanesParams(packetHandle, value.closedLanes, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "restriction");
  value.restriction.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.restriction.isValidFlag==1)
  {
    GetDENMRestrictedTypesParams(packetHandle, value.restriction, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimit");
  value.speedLimit.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.speedLimit.isValidFlag==1)
  {
    value.speedLimit.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "incidentIndication");
  value.incidentIndication.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.incidentIndication.isValidFlag==1)
  {
    GetDENMCauseCodeParams(packetHandle, value.incidentIndication, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "recommendedPath");
  value.recommendedPath.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.recommendedPath.isValidFlag==1)
  {
    GetDENMItineraryPathParams(packetHandle, value.recommendedPath, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "startingPointSpeedLimit");
  value.startingPointSpeedLimit.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.startingPointSpeedLimit.isValidFlag==1)
  {
    GetDENMDeltaReferencePositionParams(packetHandle, value.startingPointSpeedLimit, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "trafficFlowRule");
  value.trafficFlowRule.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.trafficFlowRule.isValidFlag==1)
  {
    value.trafficFlowRule.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "referenceDenms");
  value.referenceDenms.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.referenceDenms.isValidFlag==1)
  {
    GetDENMReferenceDenmsParams(packetHandle, value.referenceDenms, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  return result;
}

int SetDENMRoadWorksContainerExtendedParams(LONG packetHandle, struct DENMRoadWorksContainerExtended value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lightBarSirenInUse");
  if(value.lightBarSirenInUse.isValidFlag==1)
  {
      for(j=0; j<value.lightBarSirenInUse.stringLength; j++)
      {
        if(value.lightBarSirenInUse.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "DENM", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "DENM", newPath, j, 1);
        }
        result = CheckLastError("DENM", gkFuncRefGet, result);
      }
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "closedLanes");
  if(value.closedLanes.isValidFlag==1)
  {
    SetDENMClosedLanesParams(packetHandle, value.closedLanes, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "restriction");
  if(value.restriction.isValidFlag==1)
  {
    SetDENMRestrictedTypesParams(packetHandle, value.restriction, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimit");
  if(value.speedLimit.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "DENM", newPath, value.speedLimit.value);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "incidentIndication");
  if(value.incidentIndication.isValidFlag==1)
  {
    SetDENMCauseCodeParams(packetHandle, value.incidentIndication, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "recommendedPath");
  if(value.recommendedPath.isValidFlag==1)
  {
    SetDENMItineraryPathParams(packetHandle, value.recommendedPath, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "startingPointSpeedLimit");
  if(value.startingPointSpeedLimit.isValidFlag==1)
  {
    SetDENMDeltaReferencePositionParams(packetHandle, value.startingPointSpeedLimit, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "trafficFlowRule");
  if(value.trafficFlowRule.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "DENM", newPath, value.trafficFlowRule.value);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "referenceDenms");
  if(value.referenceDenms.isValidFlag==1)
  {
    SetDENMReferenceDenmsParams(packetHandle, value.referenceDenms, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  return result;
}

int GetDENMDangerousGoodsExtendedParams(LONG packetHandle, struct DENMDangerousGoodsExtended value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "dangerousGoodsType");
  value.dangerousGoodsType = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "unNumber");
  value.unNumber = C2xGetTokenInt(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevatedTemperature");
  value.elevatedTemperature = C2xGetTokenInt64(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "tunnelsRestricted");
  value.tunnelsRestricted = C2xGetTokenInt64(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "limitedQuantity");
  value.limitedQuantity = C2xGetTokenInt64(packetHandle, "DENM", newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "emergencyActionCode");
  value.emergencyActionCode.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.emergencyActionCode.isValidFlag==1)
  {
    value.emergencyActionCode.stringLength = C2xGetTokenData(packetHandle, "DENM", newPath, elcount(value.emergencyActionCode.string), value.emergencyActionCode.string);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "phoneNumber");
  value.phoneNumber.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.phoneNumber.isValidFlag==1)
  {
    value.phoneNumber.stringLength = C2xGetTokenData(packetHandle, "DENM", newPath, elcount(value.phoneNumber.string), value.phoneNumber.string);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "companyName");
  value.companyName.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.companyName.isValidFlag==1)
  {
    value.companyName.stringLength = C2xGetTokenData(packetHandle, "DENM", newPath, elcount(value.companyName.string), value.companyName.string);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  return result;
}

int SetDENMDangerousGoodsExtendedParams(LONG packetHandle, struct DENMDangerousGoodsExtended value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "dangerousGoodsType");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.dangerousGoodsType);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "unNumber");
  C2xSetTokenInt(packetHandle, "DENM", newPath, value.unNumber);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevatedTemperature");
  C2xSetTokenInt64(packetHandle, "DENM", newPath, value.elevatedTemperature);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "tunnelsRestricted");
  C2xSetTokenInt64(packetHandle, "DENM", newPath, value.tunnelsRestricted);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "limitedQuantity");
  C2xSetTokenInt64(packetHandle, "DENM", newPath, value.limitedQuantity);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "emergencyActionCode");
  if(value.emergencyActionCode.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "DENM", newPath, value.emergencyActionCode.stringLength, value.emergencyActionCode.string);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "phoneNumber");
  if(value.phoneNumber.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "DENM", newPath, value.phoneNumber.stringLength, value.phoneNumber.string);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "companyName");
  if(value.companyName.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "DENM", newPath, value.companyName.stringLength, value.companyName.string);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  return result;
}

int GetDENMVehicleIdentificationParams(LONG packetHandle, struct DENMVehicleIdentification value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "wMInumber");
  value.wMInumber.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.wMInumber.isValidFlag==1)
  {
    value.wMInumber.stringLength = C2xGetTokenData(packetHandle, "DENM", newPath, elcount(value.wMInumber.string), value.wMInumber.string);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vDS");
  value.vDS.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.vDS.isValidFlag==1)
  {
    value.vDS.stringLength = C2xGetTokenData(packetHandle, "DENM", newPath, elcount(value.vDS.string), value.vDS.string);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  return result;
}

int SetDENMVehicleIdentificationParams(LONG packetHandle, struct DENMVehicleIdentification value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "wMInumber");
  if(value.wMInumber.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "DENM", newPath, value.wMInumber.stringLength, value.wMInumber.string);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vDS");
  if(value.vDS.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "DENM", newPath, value.vDS.stringLength, value.vDS.string);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  return result;
}

int GetDENMStationaryVehicleContainerParams(LONG packetHandle, struct DENMStationaryVehicleContainer value, char oldPath[])
{
  char newPath[300]; 
  int j; 
  int k;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationarySince");
  value.stationarySince.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.stationarySince.isValidFlag==1)
  {
    value.stationarySince.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationaryCause");
  value.stationaryCause.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.stationaryCause.isValidFlag==1)
  {
    GetDENMCauseCodeParams(packetHandle, value.stationaryCause, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "carryingDangerousGoods");
  value.carryingDangerousGoods.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.carryingDangerousGoods.isValidFlag==1)
  {
    GetDENMDangerousGoodsExtendedParams(packetHandle, value.carryingDangerousGoods, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "numberOfOccupants");
  value.numberOfOccupants.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.numberOfOccupants.isValidFlag==1)
  {
    value.numberOfOccupants.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vehicleIdentification");
  value.vehicleIdentification.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.vehicleIdentification.isValidFlag==1)
  {
    GetDENMVehicleIdentificationParams(packetHandle, value.vehicleIdentification, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "energyStorageType");
  value.energyStorageType.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.energyStorageType.isValidFlag==1)
  {
    value.energyStorageType.isValidFlag = 1;
    value.energyStorageType.stringLength = C2xGetTokenLengthBit(packetHandle, "DENM", newPath);
    if ((result = CheckLastError("DENM", gkFuncRefGet, result))==0)
    {
      if(value.energyStorageType.stringLength > 0)
      {
        for(j=0; j<value.energyStorageType.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "DENM", newPath, j) == 0)
          {
            value.energyStorageType.string[j] = '0';
          }
          else if(C2xGetTokenBitOfBitString(packetHandle, "DENM", newPath, j) == 1)
          {
            value.energyStorageType.string[j] = '1';
          }

          if(value.energyStorageType.stringLength == 1)
          {
            value.energyStorageType.string[1] = '0';
          }
          result = CheckLastError("DENM", gkFuncRefGet, result);
        }
      }
      else
      {
        for(k = value.energyStorageType.stringLength+1; k > -1; k--)
        {
          if(value.energyStorageType.string[k] == '1')
          {
            value.energyStorageType.string[k] = '0';
          }
        }
      }
    }

  }
  return result;
}

int SetDENMStationaryVehicleContainerParams(LONG packetHandle, struct DENMStationaryVehicleContainer value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationarySince");
  if(value.stationarySince.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "DENM", newPath, value.stationarySince.value);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationaryCause");
  if(value.stationaryCause.isValidFlag==1)
  {
    SetDENMCauseCodeParams(packetHandle, value.stationaryCause, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "carryingDangerousGoods");
  if(value.carryingDangerousGoods.isValidFlag==1)
  {
    SetDENMDangerousGoodsExtendedParams(packetHandle, value.carryingDangerousGoods, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "numberOfOccupants");
  if(value.numberOfOccupants.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "DENM", newPath, value.numberOfOccupants.value);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vehicleIdentification");
  if(value.vehicleIdentification.isValidFlag==1)
  {
    SetDENMVehicleIdentificationParams(packetHandle, value.vehicleIdentification, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "energyStorageType");
  if(value.energyStorageType.isValidFlag==1)
  {
      for(j=0; j<value.energyStorageType.stringLength; j++)
      {
        if(value.energyStorageType.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "DENM", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "DENM", newPath, j, 1);
        }
        result = CheckLastError("DENM", gkFuncRefGet, result);
      }
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  return result;
}

int GetDENMAlacarteContainerParams(LONG packetHandle, struct DENMAlacarteContainer value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lanePosition");
  value.lanePosition.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.lanePosition.isValidFlag==1)
  {
    value.lanePosition.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "impactReduction");
  value.impactReduction.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.impactReduction.isValidFlag==1)
  {
    GetDENMImpactReductionContainerParams(packetHandle, value.impactReduction, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "externalTemperature");
  value.externalTemperature.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.externalTemperature.isValidFlag==1)
  {
    value.externalTemperature.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "roadWorks");
  value.roadWorks.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.roadWorks.isValidFlag==1)
  {
    GetDENMRoadWorksContainerExtendedParams(packetHandle, value.roadWorks, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "positioningSolution");
  value.positioningSolution.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.positioningSolution.isValidFlag==1)
  {
    value.positioningSolution.value = C2xGetTokenInt(packetHandle, "DENM", newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationaryVehicle");
  value.stationaryVehicle.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.stationaryVehicle.isValidFlag==1)
  {
    GetDENMStationaryVehicleContainerParams(packetHandle, value.stationaryVehicle, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  return result;
}

int SetDENMAlacarteContainerParams(LONG packetHandle, struct DENMAlacarteContainer value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lanePosition");
  if(value.lanePosition.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "DENM", newPath, value.lanePosition.value);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "impactReduction");
  if(value.impactReduction.isValidFlag==1)
  {
    SetDENMImpactReductionContainerParams(packetHandle, value.impactReduction, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "externalTemperature");
  if(value.externalTemperature.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "DENM", newPath, value.externalTemperature.value);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "roadWorks");
  if(value.roadWorks.isValidFlag==1)
  {
    SetDENMRoadWorksContainerExtendedParams(packetHandle, value.roadWorks, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "positioningSolution");
  if(value.positioningSolution.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "DENM", newPath, value.positioningSolution.value);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationaryVehicle");
  if(value.stationaryVehicle.isValidFlag==1)
  {
    SetDENMStationaryVehicleContainerParams(packetHandle, value.stationaryVehicle, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  return result;
}

int GetDENMDecentralizedEnvironmentalNotificationMessageParams(LONG packetHandle, struct DENMDecentralizedEnvironmentalNotificationMessage value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "management");
  GetDENMManagementContainerParams(packetHandle, value.management, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "situation");
  value.situation.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.situation.isValidFlag==1)
  {
    GetDENMSituationContainerParams(packetHandle, value.situation, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "location");
  value.location.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.location.isValidFlag==1)
  {
    GetDENMLocationContainerParams(packetHandle, value.location, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "alacarte");
  value.alacarte.isValidFlag = C2xIsTokenAvailable(packetHandle, "DENM", newPath);
  if(value.alacarte.isValidFlag==1)
  {
    GetDENMAlacarteContainerParams(packetHandle, value.alacarte, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  return result;
}

int SetDENMDecentralizedEnvironmentalNotificationMessageParams(LONG packetHandle, struct DENMDecentralizedEnvironmentalNotificationMessage value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "management");
  SetDENMManagementContainerParams(packetHandle, value.management, newPath);
  result = CheckLastError("DENM", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "situation");
  if(value.situation.isValidFlag==1)
  {
    SetDENMSituationContainerParams(packetHandle, value.situation, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "location");
  if(value.location.isValidFlag==1)
  {
    SetDENMLocationContainerParams(packetHandle, value.location, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "alacarte");
  if(value.alacarte.isValidFlag==1)
  {
    SetDENMAlacarteContainerParams(packetHandle, value.alacarte, newPath);
    result = CheckLastError("DENM", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "DENM", newPath) )
    {
      C2xRemoveToken(packetHandle, "DENM", newPath);
    }
  }

  return result;
}

int API_GetDENMParams(LONG packetHandle, struct DENM value)
{
  int result;
  result = 0;

  value.header.isValidFlag = 1;
  GetDENMItsPduHeaderParams(packetHandle, value.header, "header");
  result = CheckLastError("DENM", gkFuncRefGet, result);

  value.denm.isValidFlag = 1;
  GetDENMDecentralizedEnvironmentalNotificationMessageParams(packetHandle, value.denm, "denm");
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

int API_SetDENMParams(LONG packetHandle, struct DENM value)
{
  int result;
  result = 0;

  SetDENMItsPduHeaderParams(packetHandle, value.header, "header");
  result = CheckLastError("DENM", gkFuncRefGet, result);

  SetDENMDecentralizedEnvironmentalNotificationMessageParams(packetHandle, value.denm, "denm");
  result = CheckLastError("DENM", gkFuncRefGet, result);

  return result;
}

